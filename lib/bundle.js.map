{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://typewriter/./node_modules/.pnpm/@typewriter+delta@1.0.2/node_modules/@typewriter/delta/dist/AttributeMap.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+delta@1.0.2/node_modules/@typewriter/delta/dist/Delta.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+delta@1.0.2/node_modules/@typewriter/delta/dist/Op.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+delta@1.0.2/node_modules/@typewriter/delta/dist/index.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+delta@1.0.2/node_modules/@typewriter/delta/dist/util/cloneDeep.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+delta@1.0.2/node_modules/@typewriter/delta/dist/util/isEqual.js","webpack://typewriter/./node_modules/.pnpm/fast-diff@1.2.0/node_modules/fast-diff/diff.js","webpack://typewriter/./src/Editor.ts","webpack://typewriter/./src/Source.ts","webpack://typewriter/./src/modules/copy.ts","webpack://typewriter/./src/modules/decorations.ts","webpack://typewriter/./src/modules/defaults.ts","webpack://typewriter/./src/modules/history.ts","webpack://typewriter/./src/modules/placeholder.ts","webpack://typewriter/./src/modules/smartQuotes.ts","webpack://typewriter/./src/modules/smartEntry.ts","webpack://typewriter/./src/modules/input.ts","webpack://typewriter/./src/modules/keyboard.ts","webpack://typewriter/./src/modules/paste.ts","webpack://typewriter/./src/modules/rendering.ts","webpack://typewriter/./src/modules/selection.ts","webpack://typewriter/./src/modules/shortcutFromEvent.ts","webpack://typewriter/./src/rendering/escape-html.ts","webpack://typewriter/./src/rendering/html.ts","webpack://typewriter/./src/rendering/position.ts","webpack://typewriter/./src/rendering/rendering.ts","webpack://typewriter/./src/rendering/selection.ts","webpack://typewriter/./src/rendering/vdom.ts","webpack://typewriter/./src/rendering/walker.ts","webpack://typewriter/./node_modules/.pnpm/svelte@3.48.0/node_modules/svelte/internal/index.mjs","webpack://typewriter/./node_modules/.pnpm/svelte@3.48.0/node_modules/svelte/store/index.mjs","webpack://typewriter/./src/stores.ts","webpack://typewriter/./src/typesetting/lines.ts","webpack://typewriter/./src/typesetting/formats.ts","webpack://typewriter/./src/typesetting/embeds.ts","webpack://typewriter/./src/typesetting/defaults.ts","webpack://typewriter/./src/typesetting/typeset.ts","webpack://typewriter/./src/util/EventDispatcher.ts","webpack://typewriter/./node_modules/.pnpm/@typewriter+document@0.7.3/node_modules/@typewriter/document/lib/EditorRange.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+document@0.7.3/node_modules/@typewriter/document/lib/Line.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+document@0.7.3/node_modules/@typewriter/document/lib/LineOp.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+document@0.7.3/node_modules/@typewriter/document/lib/TextChange.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+document@0.7.3/node_modules/@typewriter/document/lib/TextDocument.js","webpack://typewriter/./node_modules/.pnpm/@typewriter+document@0.7.3/node_modules/@typewriter/document/lib/deltaToText.js","webpack://typewriter/webpack/bootstrap","webpack://typewriter/webpack/runtime/compat get default export","webpack://typewriter/webpack/runtime/define property getters","webpack://typewriter/webpack/runtime/hasOwnProperty shorthand","webpack://typewriter/webpack/runtime/make namespace object"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst cloneDeep_1 = __importDefault(require(\"./util/cloneDeep\"));\nconst isEqual_1 = __importDefault(require(\"./util/isEqual\"));\nfunction isObject(value) {\n    return value === Object(value) && !Array.isArray(value);\n}\nfunction isDeepNull(value) {\n    if (value == null)\n        return true;\n    if (!isObject(value))\n        return false;\n    for (const key in value) {\n        if (!isDeepNull(value[key]))\n            return false;\n    }\n    return true;\n}\nvar AttributeMap;\n(function (AttributeMap) {\n    function compose(a = {}, b = {}, keepNull) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        let attributes = (0, cloneDeep_1.default)(b);\n        for (const key in a) {\n            if (isObject(a[key]) && isObject(attributes[key])) {\n                attributes[key] = compose(a[key], attributes[key], keepNull);\n            }\n        }\n        if (!keepNull) {\n            attributes = Object.keys(attributes).reduce((copy, key) => {\n                if (!isDeepNull(attributes[key])) {\n                    copy[key] = attributes[key];\n                }\n                return copy;\n            }, {});\n        }\n        for (const key in a) {\n            if (a[key] !== undefined && b[key] === undefined) {\n                attributes[key] = a[key];\n            }\n        }\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.compose = compose;\n    function diff(a = {}, b = {}) {\n        if (typeof a !== 'object') {\n            a = {};\n        }\n        if (typeof b !== 'object') {\n            b = {};\n        }\n        const attributes = Object.keys(a)\n            .concat(Object.keys(b))\n            .reduce((attrs, key) => {\n            if (!(0, isEqual_1.default)(a[key], b[key])) {\n                if (b[key] === undefined) {\n                    attrs[key] = null;\n                }\n                else if (isObject(a[key]) && isObject(b[key])) {\n                    attrs[key] = diff(a[key], b[key]);\n                }\n                else {\n                    attrs[key] = b[key];\n                }\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.diff = diff;\n    function invert(attr = {}, base = {}) {\n        attr = attr || {};\n        const baseInverted = Object.keys(base).reduce((memo, key) => {\n            if (!(0, isEqual_1.default)(base[key], attr[key]) && attr[key] !== undefined) {\n                if (isObject(attr[key]) && isObject(base[key])) {\n                    memo[key] = invert(attr[key], base[key]);\n                }\n                else {\n                    memo[key] = base[key];\n                }\n            }\n            return memo;\n        }, {});\n        return Object.keys(attr).reduce((memo, key) => {\n            if (attr[key] !== base[key] && base[key] === undefined) {\n                memo[key] = null;\n            }\n            return memo;\n        }, baseInverted);\n    }\n    AttributeMap.invert = invert;\n    function transform(a, b, priority = false) {\n        if (typeof a !== 'object') {\n            return b;\n        }\n        if (typeof b !== 'object') {\n            return undefined;\n        }\n        if (!priority) {\n            return b; // b simply overwrites us without priority\n        }\n        const attributes = Object.keys(b).reduce((attrs, key) => {\n            if (a[key] === undefined) {\n                attrs[key] = b[key]; // null is a valid value\n            }\n            else if (isObject(a[key]) && isObject(b[key])) {\n                attrs[key] = transform(a[key], b[key], true);\n            }\n            return attrs;\n        }, {});\n        return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n    AttributeMap.transform = transform;\n})(AttributeMap || (AttributeMap = {}));\nexports.default = AttributeMap;\n//# sourceMappingURL=AttributeMap.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fast_diff_1 = __importDefault(require(\"fast-diff\"));\nconst isEqual_1 = __importDefault(require(\"./util/isEqual\"));\nconst AttributeMap_1 = __importDefault(require(\"./AttributeMap\"));\nconst Op_1 = __importDefault(require(\"./Op\"));\nconst NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()\nclass Delta {\n    constructor(ops) {\n        // Assume we are given a well formed ops\n        if (Array.isArray(ops)) {\n            this.ops = ops;\n        }\n        else if (ops != null && Array.isArray(ops.ops)) {\n            this.ops = ops.ops;\n        }\n        else {\n            this.ops = [];\n        }\n    }\n    insert(arg, attributes) {\n        const newOp = {};\n        if (typeof arg === 'string' && arg.length === 0) {\n            return this;\n        }\n        newOp.insert = arg;\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    delete(length) {\n        if (length <= 0) {\n            return this;\n        }\n        return this.push({ delete: length });\n    }\n    retain(length, attributes) {\n        if (length <= 0) {\n            return this;\n        }\n        const newOp = { retain: length };\n        if (attributes != null &&\n            typeof attributes === 'object' &&\n            Object.keys(attributes).length > 0) {\n            newOp.attributes = attributes;\n        }\n        return this.push(newOp);\n    }\n    push(newOp) {\n        let index = this.ops.length;\n        let lastOp = this.ops[index - 1];\n        if (typeof lastOp === 'object') {\n            if (typeof newOp.delete === 'number' &&\n                typeof lastOp.delete === 'number') {\n                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };\n                return this;\n            }\n            // Since it does not matter if we insert before or after deleting at the same index,\n            // always prefer to insert first\n            if (typeof lastOp.delete === 'number' && newOp.insert != null) {\n                index -= 1;\n                lastOp = this.ops[index - 1];\n                if (typeof lastOp !== 'object') {\n                    this.ops.unshift(newOp);\n                    return this;\n                }\n            }\n            if ((0, isEqual_1.default)(newOp.attributes, lastOp.attributes)) {\n                if (typeof newOp.insert === 'string' &&\n                    typeof lastOp.insert === 'string') {\n                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n                else if (typeof newOp.retain === 'number' &&\n                    typeof lastOp.retain === 'number') {\n                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n                    if (typeof newOp.attributes === 'object') {\n                        this.ops[index - 1].attributes = newOp.attributes;\n                    }\n                    return this;\n                }\n            }\n        }\n        if (index === this.ops.length) {\n            this.ops.push(newOp);\n        }\n        else {\n            this.ops.splice(index, 0, newOp);\n        }\n        return this;\n    }\n    chop() {\n        const lastOp = this.ops[this.ops.length - 1];\n        if (lastOp && lastOp.retain && !lastOp.attributes) {\n            this.ops.pop();\n        }\n        return this;\n    }\n    filter(predicate) {\n        return this.ops.filter(predicate);\n    }\n    forEach(predicate) {\n        this.ops.forEach(predicate);\n    }\n    map(predicate) {\n        return this.ops.map(predicate);\n    }\n    partition(predicate) {\n        const passed = [];\n        const failed = [];\n        this.forEach((op) => {\n            const target = predicate(op) ? passed : failed;\n            target.push(op);\n        });\n        return [passed, failed];\n    }\n    reduce(predicate, initialValue) {\n        return this.ops.reduce(predicate, initialValue);\n    }\n    changeLength() {\n        return this.reduce((length, elem) => {\n            if (elem.insert) {\n                return length + Op_1.default.length(elem);\n            }\n            else if (elem.delete) {\n                return length - elem.delete;\n            }\n            return length;\n        }, 0);\n    }\n    length() {\n        return this.reduce((length, elem) => {\n            return length + Op_1.default.length(elem);\n        }, 0);\n    }\n    slice(start = 0, end = Infinity) {\n        const ops = [];\n        const iter = Op_1.default.iterator(this.ops);\n        let index = 0;\n        while (index < end && iter.hasNext()) {\n            let nextOp;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op_1.default.length(nextOp);\n        }\n        return new Delta(ops);\n    }\n    compose(other, discardNull) {\n        const thisIter = Op_1.default.iterator(this.ops);\n        const otherIter = Op_1.default.iterator(other.ops);\n        const ops = [];\n        const firstOther = otherIter.peek();\n        if (firstOther != null &&\n            typeof firstOther.retain === 'number' &&\n            firstOther.attributes == null) {\n            let firstLeft = firstOther.retain;\n            while (thisIter.peekType() === 'insert' &&\n                thisIter.peekLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLength();\n                ops.push(thisIter.next());\n            }\n            if (firstOther.retain - firstLeft > 0) {\n                otherIter.next(firstOther.retain - firstLeft);\n            }\n        }\n        const delta = new Delta(ops);\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else if (thisIter.peekType() === 'delete') {\n                delta.push(thisIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (typeof otherOp.retain === 'number') {\n                    let newOp;\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    const attributes = otherOp.attributes &&\n                        AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, !discardNull && typeof thisOp.retain === 'number');\n                    if (otherOp.attributes && !(0, isEqual_1.default)(attributes, thisOp.attributes)) {\n                        newOp = {};\n                        if (typeof thisOp.retain === 'number') {\n                            newOp.retain = length;\n                        }\n                        else {\n                            newOp.insert = thisOp.insert;\n                        }\n                        if (attributes) {\n                            newOp.attributes = attributes;\n                        }\n                    }\n                    else if (thisOp.retain === Infinity) {\n                        newOp = otherOp;\n                    }\n                    else {\n                        newOp = thisOp;\n                    }\n                    delta.push(newOp);\n                    // Optimization if rest of other is just retain\n                    if (otherOp.retain === Infinity ||\n                        (!otherIter.hasNext() &&\n                            (0, isEqual_1.default)(delta.ops[delta.ops.length - 1], newOp))) {\n                        const rest = new Delta(thisIter.rest());\n                        return delta.concat(rest).chop();\n                    }\n                    // Other op should be delete, we could be an insert or retain\n                    // Insert + delete cancels out\n                }\n                else if (typeof otherOp.delete === 'number' &&\n                    typeof thisOp.retain === 'number') {\n                    delta.push(otherOp);\n                }\n            }\n        }\n        return delta.chop();\n    }\n    concat(other) {\n        const delta = new Delta(this.ops.slice());\n        if (other.ops.length > 0) {\n            delta.push(other.ops[0]);\n            delta.ops = delta.ops.concat(other.ops.slice(1));\n        }\n        return delta;\n    }\n    diff(other, cursor) {\n        if (this.ops === other.ops) {\n            return new Delta();\n        }\n        const strings = [this, other].map((delta) => {\n            return delta\n                .map((op) => {\n                if (op.insert != null) {\n                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n                }\n                const prep = delta === other ? 'on' : 'with';\n                throw new Error('diff() called ' + prep + ' non-document');\n            })\n                .join('');\n        });\n        const retDelta = new Delta();\n        const diffResult = (0, fast_diff_1.default)(strings[0], strings[1], cursor);\n        const thisIter = Op_1.default.iterator(this.ops);\n        const otherIter = Op_1.default.iterator(other.ops);\n        diffResult.forEach((component) => {\n            let length = component[1].length;\n            while (length > 0) {\n                let opLength = 0;\n                switch (component[0]) {\n                    case fast_diff_1.default.INSERT:\n                        opLength = Math.min(otherIter.peekLength(), length);\n                        retDelta.push(otherIter.next(opLength));\n                        break;\n                    case fast_diff_1.default.DELETE:\n                        opLength = Math.min(length, thisIter.peekLength());\n                        thisIter.next(opLength);\n                        retDelta.delete(opLength);\n                        break;\n                    case fast_diff_1.default.EQUAL:\n                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n                        const thisOp = thisIter.next(opLength);\n                        const otherOp = otherIter.next(opLength);\n                        if ((0, isEqual_1.default)(thisOp.insert, otherOp.insert)) {\n                            retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));\n                        }\n                        else {\n                            retDelta.push(otherOp).delete(opLength);\n                        }\n                        break;\n                }\n                length -= opLength;\n            }\n        });\n        return retDelta.chop();\n    }\n    eachLine(predicate, newline = '\\n') {\n        const iter = Op_1.default.iterator(this.ops);\n        let line = new Delta();\n        let i = 0;\n        while (iter.hasNext()) {\n            if (iter.peekType() !== 'insert') {\n                return;\n            }\n            const thisOp = iter.peek();\n            const start = Op_1.default.length(thisOp) - iter.peekLength();\n            const index = typeof thisOp.insert === 'string'\n                ? thisOp.insert.indexOf(newline, start) - start\n                : -1;\n            if (index < 0) {\n                line.push(iter.next());\n            }\n            else if (index > 0) {\n                line.push(iter.next(index));\n            }\n            else {\n                if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n                    return;\n                }\n                i += 1;\n                line = new Delta();\n            }\n        }\n        if (line.length() > 0) {\n            predicate(line, {}, i);\n        }\n    }\n    invert(base) {\n        const inverted = new Delta();\n        this.reduce((baseIndex, op) => {\n            if (op.insert) {\n                inverted.delete(Op_1.default.length(op));\n            }\n            else if (op.retain && op.attributes == null) {\n                inverted.retain(op.retain);\n                return baseIndex + op.retain;\n            }\n            else if (op.delete || op.retain) {\n                const length = (op.delete || op.retain);\n                const slice = base.slice(baseIndex, baseIndex + length);\n                slice.forEach((baseOp) => {\n                    if (op.delete) {\n                        inverted.push(baseOp);\n                    }\n                    else if (op.retain && op.attributes) {\n                        inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));\n                    }\n                });\n                return baseIndex + length;\n            }\n            return baseIndex;\n        }, 0);\n        return inverted.chop();\n    }\n    transform(arg, priority = false) {\n        priority = !!priority;\n        if (typeof arg === 'number') {\n            return this.transformPosition(arg, priority);\n        }\n        const other = arg;\n        const thisIter = Op_1.default.iterator(this.ops);\n        const otherIter = Op_1.default.iterator(other.ops);\n        const delta = new Delta();\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (thisIter.peekType() === 'insert' &&\n                (priority || otherIter.peekType() !== 'insert')) {\n                delta.retain(Op_1.default.length(thisIter.next()));\n            }\n            else if (otherIter.peekType() === 'insert') {\n                delta.push(otherIter.next());\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (thisOp.delete) {\n                    // Our delete either makes their delete redundant or removes their retain\n                    continue;\n                }\n                else if (otherOp.delete) {\n                    delta.push(otherOp);\n                }\n                else {\n                    // We retain either their retain or insert\n                    delta.retain(length, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));\n                }\n            }\n        }\n        return delta.chop();\n    }\n    transformPosition(index, priority = false) {\n        priority = !!priority;\n        const thisIter = Op_1.default.iterator(this.ops);\n        let offset = 0;\n        while (thisIter.hasNext() && offset <= index) {\n            const length = thisIter.peekLength();\n            const nextType = thisIter.peekType();\n            thisIter.next();\n            if (nextType === 'delete') {\n                index -= Math.min(length, index - offset);\n                continue;\n            }\n            else if (nextType === 'insert' && (offset < index || !priority)) {\n                index += length;\n            }\n            offset += length;\n        }\n        return index;\n    }\n}\nDelta.Op = Op_1.default;\nDelta.AttributeMap = AttributeMap_1.default;\nexports.default = Delta;\nif (typeof module === 'object') {\n    module.exports = Delta;\n    module.exports.default = Delta;\n}\n//# sourceMappingURL=Delta.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OpIterator = void 0;\nvar Op;\n(function (Op) {\n    function iterator(ops) {\n        return new OpIterator(ops);\n    }\n    Op.iterator = iterator;\n    function length(op) {\n        if (typeof op.delete === 'number') {\n            return op.delete;\n        }\n        else if (typeof op.retain === 'number') {\n            return op.retain;\n        }\n        else {\n            return typeof op.insert === 'string' ? op.insert.length : 1;\n        }\n    }\n    Op.length = length;\n})(Op || (Op = {}));\nexports.default = Op;\nclass OpIterator {\n    constructor(ops) {\n        this.ops = ops;\n        this.index = 0;\n        this.offset = 0;\n    }\n    hasNext() {\n        return !!this.peek();\n    }\n    next(length) {\n        if (!length) {\n            length = Infinity;\n        }\n        const nextOp = this.ops[this.index];\n        if (nextOp) {\n            const offset = this.offset;\n            const opLength = Op.length(nextOp);\n            if (length >= opLength - offset) {\n                length = opLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (typeof nextOp.delete === 'number') {\n                return { delete: length };\n            }\n            else {\n                if (opLength === length)\n                    return nextOp;\n                const retOp = {};\n                if (nextOp.attributes) {\n                    retOp.attributes = nextOp.attributes;\n                }\n                if (typeof nextOp.retain === 'number') {\n                    retOp.retain = length;\n                }\n                else if (typeof nextOp.insert === 'string') {\n                    retOp.insert = nextOp.insert.substr(offset, length);\n                }\n                else {\n                    // offset should === 0, length should === 1\n                    retOp.insert = nextOp.insert;\n                }\n                return retOp;\n            }\n        }\n        else {\n            return { retain: Infinity };\n        }\n    }\n    peek() {\n        return this.ops[this.index];\n    }\n    peekLength() {\n        if (this.ops[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return Op.length(this.ops[this.index]) - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    }\n    peekType() {\n        const op = this.ops[this.index];\n        if (op) {\n            if (typeof op.delete === 'number') {\n                return 'delete';\n            }\n            else if (typeof op.retain === 'number') {\n                return 'retain';\n            }\n            else {\n                return 'insert';\n            }\n        }\n        return 'retain';\n    }\n    rest() {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.ops.slice(this.index);\n        }\n        else {\n            const offset = this.offset;\n            const index = this.index;\n            const next = this.next();\n            const rest = this.ops.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    }\n}\nexports.OpIterator = OpIterator;\n//# sourceMappingURL=Op.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.diff = exports.isEqual = exports.cloneDeep = exports.OpIterator = exports.Op = exports.Delta = exports.AttributeMap = void 0;\nvar AttributeMap_1 = require(\"./AttributeMap\");\nObject.defineProperty(exports, \"AttributeMap\", { enumerable: true, get: function () { return __importDefault(AttributeMap_1).default; } });\nvar Delta_1 = require(\"./Delta\");\nObject.defineProperty(exports, \"Delta\", { enumerable: true, get: function () { return __importDefault(Delta_1).default; } });\nvar Op_1 = require(\"./Op\");\nObject.defineProperty(exports, \"Op\", { enumerable: true, get: function () { return __importDefault(Op_1).default; } });\nObject.defineProperty(exports, \"OpIterator\", { enumerable: true, get: function () { return Op_1.OpIterator; } });\nconst cloneDeep_1 = __importDefault(require(\"./util/cloneDeep\"));\nexports.cloneDeep = cloneDeep_1.default;\nconst isEqual_1 = __importDefault(require(\"./util/isEqual\"));\nexports.isEqual = isEqual_1.default;\nconst fast_diff_1 = __importDefault(require(\"fast-diff\"));\nexports.diff = fast_diff_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Just work with plain objects and arrays\nfunction cloneDeep(value) {\n    if (!value)\n        return value;\n    if (typeof value.toJSON === 'function')\n        value = value.toJSON();\n    if (Array.isArray(value))\n        return value.map(cloneDeep);\n    if (typeof value === 'object') {\n        const clone = {};\n        Object.keys(value).forEach((key) => (clone[key] = cloneDeep(value[key])));\n        return clone;\n    }\n    return value;\n}\nexports.default = cloneDeep;\n//# sourceMappingURL=cloneDeep.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst EMPTY_OBJ = {};\nfunction isEqual(value, other, options = EMPTY_OBJ) {\n    if (value === other)\n        return true;\n    const valueType = typeof value;\n    const otherType = typeof value;\n    // Special case for NaN\n    if (valueType === 'number' &&\n        otherType === 'number' &&\n        isNaN(value) &&\n        isNaN(other))\n        return true;\n    // If a basic type or not the same class\n    if (!value ||\n        !other ||\n        valueType !== 'object' ||\n        otherType !== 'object' ||\n        value.constructor !== other.constructor) {\n        return false;\n    }\n    // Dates\n    if (value.valueOf() !== value) {\n        return isEqual(value.valueOf(), other.valueOf(), options);\n    }\n    const compare = options.shallow ? exactlyEqual : isEqual;\n    // Iterables including arrays\n    if (typeof value[Symbol.iterator] === 'function') {\n        const valueIter = value[Symbol.iterator]();\n        const otherIter = other[Symbol.iterator]();\n        let valueResult = valueIter.next();\n        let otherResult = otherIter.next();\n        while (!valueResult.done && !otherResult.done) {\n            if (!compare(valueResult.value, otherResult.value, options))\n                return false;\n            valueResult = valueIter.next();\n            otherResult = otherIter.next();\n        }\n        return valueResult.done === otherResult.done;\n    }\n    // Objects\n    let valueKeys = Object.keys(value);\n    let otherKeys = Object.keys(other);\n    if (options.excludeProps) {\n        const isIncluded = createIsIncluded(options.excludeProps);\n        valueKeys = valueKeys.filter(isIncluded);\n        otherKeys = otherKeys.filter(isIncluded);\n    }\n    return ((options.partial || valueKeys.length === otherKeys.length) &&\n        otherKeys.every((key) => value.hasOwnProperty(key) && compare(other[key], value[key], options)));\n}\nexports.default = isEqual;\nfunction exactlyEqual(value, other) {\n    return value === other;\n}\nfunction createIsIncluded(excluded) {\n    return (prop) => !excluded.has(prop);\n}\n//# sourceMappingURL=isEqual.js.map","/**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int|Object} [cursor_pos] Edit position in text1 or object with more info\n * @return {Array} Array of diff tuples.\n */\nfunction diff_main(text1, text2, cursor_pos, _fix_unicode) {\n  // Check for equality\n  if (text1 === text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (cursor_pos != null) {\n    var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);\n    if (editdiff) {\n      return editdiff;\n    }\n  }\n\n  // Trim off common prefix (speedup).\n  var commonlength = diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = diff_compute_(text1, text2);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  diff_cleanupMerge(diffs, _fix_unicode);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_compute_(text1, text2) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i !== -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [\n      [DIFF_INSERT, longtext.substring(0, i)],\n      [DIFF_EQUAL, shorttext],\n      [DIFF_INSERT, longtext.substring(i + shorttext.length)]\n    ];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length === 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = diff_main(text1_a, text2_a);\n    var diffs_b = diff_main(text1_b, text2_b);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  return diff_bisect_(text1, text2);\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */\nfunction diff_bisect_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 !== 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 === -d || (k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (\n        x1 < text1_length && y1 < text2_length &&\n        text1.charAt(x1) === text2.charAt(y1)\n      ) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 === -d || (k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (\n        x2 < text1_length && y2 < text2_length &&\n        text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)\n      ) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_bisectSplit_(text1, text2, x, y) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = diff_main(text1a, text2a);\n  var diffsb = diff_main(text1b, text2b);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nfunction diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(pointerstart, pointermid) ==\n      text2.substring(pointerstart, pointermid)\n    ) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nfunction diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (\n      text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n      text2.substring(text2.length - pointermid, text2.length - pointerend)\n    ) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n\n  if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {\n    pointermid--;\n  }\n\n  return pointermid;\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */\nfunction diff_halfMatch_(text1, text2) {\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) !== -1) {\n      var prefixLength = diff_commonPrefix(\n        longtext.substring(i), shorttext.substring(j));\n      var suffixLength = diff_commonSuffix(\n        longtext.substring(0, i), shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(\n          j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [\n        best_longtext_a, best_longtext_b,\n        best_shorttext_a, best_shorttext_b, best_common\n      ];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n * @param {boolean} fix_unicode Whether to normalize to a unicode-correct diff\n */\nfunction diff_cleanupMerge(diffs, fix_unicode) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n      diffs.splice(pointer, 1);\n      continue;\n    }\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        var previous_equality = pointer - count_insert - count_delete - 1;\n        if (fix_unicode) {\n          // prevent splitting of unicode surrogate pairs.  when fix_unicode is true,\n          // we assume that the old and new text in the diff are complete and correct\n          // unicode-encoded JS strings, but the tuple boundaries may fall between\n          // surrogate pairs.  we fix this by shaving off stray surrogates from the end\n          // of the previous equality and the beginning of this equality.  this may create\n          // empty equalities or a common prefix or suffix.  for example, if AB and AC are\n          // emojis, `[[0, 'A'], [-1, 'BA'], [0, 'C']]` would turn into deleting 'ABAC' and\n          // inserting 'AC', and then the common suffix 'AC' will be eliminated.  in this\n          // particular case, both equalities go away, we absorb any previous inequalities,\n          // and we keep scanning for the next equality before rewriting the tuples.\n          if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {\n            var stray = diffs[previous_equality][1].slice(-1);\n            diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);\n            text_delete = stray + text_delete;\n            text_insert = stray + text_insert;\n            if (!diffs[previous_equality][1]) {\n              // emptied out previous equality, so delete it and include previous delete/insert\n              diffs.splice(previous_equality, 1);\n              pointer--;\n              var k = previous_equality - 1;\n              if (diffs[k] && diffs[k][0] === DIFF_INSERT) {\n                count_insert++;\n                text_insert = diffs[k][1] + text_insert;\n                k--;\n              }\n              if (diffs[k] && diffs[k][0] === DIFF_DELETE) {\n                count_delete++;\n                text_delete = diffs[k][1] + text_delete;\n                k--;\n              }\n              previous_equality = k;\n            }\n          }\n          if (starts_with_pair_end(diffs[pointer][1])) {\n            var stray = diffs[pointer][1].charAt(0);\n            diffs[pointer][1] = diffs[pointer][1].slice(1);\n            text_delete += stray;\n            text_insert += stray;\n          }\n        }\n        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {\n          // for empty equality not at end, wait for next equality\n          diffs.splice(pointer, 1);\n          break;\n        }\n        if (text_delete.length > 0 || text_insert.length > 0) {\n          // note that diff_commonPrefix and diff_commonSuffix are unicode-aware\n          if (text_delete.length > 0 && text_insert.length > 0) {\n            // Factor out any common prefixes.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if (previous_equality >= 0) {\n                diffs[previous_equality][1] += text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixes.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] =\n                text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length - commonlength);\n              text_delete = text_delete.substring(0, text_delete.length - commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          var n = count_insert + count_delete;\n          if (text_delete.length === 0 && text_insert.length === 0) {\n            diffs.splice(pointer - n, n);\n            pointer = pointer - n;\n          } else if (text_delete.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 1;\n          } else if (text_insert.length === 0) {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);\n            pointer = pointer - n + 1;\n          } else {\n            diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);\n            pointer = pointer - n + 2;\n          }\n        }\n        if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] === DIFF_EQUAL &&\n      diffs[pointer + 1][0] === DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n        diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n          diffs[pointer][1].substring(0, diffs[pointer][1].length -\n            diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n        diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n          diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n          diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs, fix_unicode);\n  }\n};\n\nfunction is_surrogate_pair_start(charCode) {\n  return charCode >= 0xD800 && charCode <= 0xDBFF;\n}\n\nfunction is_surrogate_pair_end(charCode) {\n  return charCode >= 0xDC00 && charCode <= 0xDFFF;\n}\n\nfunction starts_with_pair_end(str) {\n  return is_surrogate_pair_end(str.charCodeAt(0));\n}\n\nfunction ends_with_pair_start(str) {\n  return is_surrogate_pair_start(str.charCodeAt(str.length - 1));\n}\n\nfunction remove_empty_tuples(tuples) {\n  var ret = [];\n  for (var i = 0; i < tuples.length; i++) {\n    if (tuples[i][1].length > 0) {\n      ret.push(tuples[i]);\n    }\n  }\n  return ret;\n}\n\nfunction make_edit_splice(before, oldMiddle, newMiddle, after) {\n  if (ends_with_pair_start(before) || starts_with_pair_end(after)) {\n    return null;\n  }\n  return remove_empty_tuples([\n    [DIFF_EQUAL, before],\n    [DIFF_DELETE, oldMiddle],\n    [DIFF_INSERT, newMiddle],\n    [DIFF_EQUAL, after]\n  ]);\n}\n\nfunction find_cursor_edit_diff(oldText, newText, cursor_pos) {\n  // note: this runs after equality check has ruled out exact equality\n  var oldRange = typeof cursor_pos === 'number' ?\n    { index: cursor_pos, length: 0 } : cursor_pos.oldRange;\n  var newRange = typeof cursor_pos === 'number' ?\n    null : cursor_pos.newRange;\n  // take into account the old and new selection to generate the best diff\n  // possible for a text edit.  for example, a text change from \"xxx\" to \"xx\"\n  // could be a delete or forwards-delete of any one of the x's, or the\n  // result of selecting two of the x's and typing \"x\".\n  var oldLength = oldText.length;\n  var newLength = newText.length;\n  if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {\n    // see if we have an insert or delete before or after cursor\n    var oldCursor = oldRange.index;\n    var oldBefore = oldText.slice(0, oldCursor);\n    var oldAfter = oldText.slice(oldCursor);\n    var maybeNewCursor = newRange ? newRange.index : null;\n    editBefore: {\n      // is this an insert or delete right before oldCursor?\n      var newCursor = oldCursor + newLength - oldLength;\n      if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {\n        break editBefore;\n      }\n      if (newCursor < 0 || newCursor > newLength) {\n        break editBefore;\n      }\n      var newBefore = newText.slice(0, newCursor);\n      var newAfter = newText.slice(newCursor);\n      if (newAfter !== oldAfter) {\n        break editBefore;\n      }\n      var prefixLength = Math.min(oldCursor, newCursor);\n      var oldPrefix = oldBefore.slice(0, prefixLength);\n      var newPrefix = newBefore.slice(0, prefixLength);\n      if (oldPrefix !== newPrefix) {\n        break editBefore;\n      }\n      var oldMiddle = oldBefore.slice(prefixLength);\n      var newMiddle = newBefore.slice(prefixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);\n    }\n    editAfter: {\n      // is this an insert or delete right after oldCursor?\n      if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {\n        break editAfter;\n      }\n      var cursor = oldCursor;\n      var newBefore = newText.slice(0, cursor);\n      var newAfter = newText.slice(cursor);\n      if (newBefore !== oldBefore) {\n        break editAfter;\n      }\n      var suffixLength = Math.min(oldLength - cursor, newLength - cursor);\n      var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);\n      var newSuffix = newAfter.slice(newAfter.length - suffixLength);\n      if (oldSuffix !== newSuffix) {\n        break editAfter;\n      }\n      var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);\n      var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);\n      return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n  if (oldRange.length > 0 && newRange && newRange.length === 0) {\n    replaceRange: {\n      // see if diff could be a splice of the old selection range\n      var oldPrefix = oldText.slice(0, oldRange.index);\n      var oldSuffix = oldText.slice(oldRange.index + oldRange.length);\n      var prefixLength = oldPrefix.length;\n      var suffixLength = oldSuffix.length;\n      if (newLength < prefixLength + suffixLength) {\n        break replaceRange;\n      }\n      var newPrefix = newText.slice(0, prefixLength);\n      var newSuffix = newText.slice(newLength - suffixLength);\n      if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {\n        break replaceRange;\n      }\n      var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);\n      var newMiddle = newText.slice(prefixLength, newLength - suffixLength);\n      return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);\n    }\n  }\n\n  return null;\n}\n\nfunction diff(text1, text2, cursor_pos) {\n  // only pass fix_unicode=true at the top level, not when diff_main is\n  // recursively invoked\n  return diff_main(text1, text2, cursor_pos, true);\n}\n\ndiff.INSERT = DIFF_INSERT;\ndiff.DELETE = DIFF_DELETE;\ndiff.EQUAL = DIFF_EQUAL;\n\nmodule.exports = diff;\n","import { TextDocument, TextChange, hasFormat, Delta, AttributeMap, EditorRange, normalizeRange, Line, isEqual } from '@typewriter/document';\nimport { Typeset, TypesetTypes, Commands, Types } from './typesetting/typeset';\nimport { defaultModules } from './modules/defaults';\nimport { defaultTypes } from './typesetting/defaults';\nimport { docFromHTML, docToHTML } from './rendering/html';\nimport EventDispatcher from './util/EventDispatcher';\nimport { getBoudingBrowserRange, getIndexFromPoint } from './rendering/position';\nimport { SourceString, Source } from './Source';\n\nconst EMPTY_OBJ = {};\nconst EMPTY_ARR = [];\nconst PROXIED_EVENTS = [ 'focus', 'blur', 'keydown', 'mousedown', 'mouseup', 'click' ];\nconst eventProxies = new WeakMap<Editor, EventListener>();\n\nexport interface EditorOptions {\n  identifier?: any;\n  root?: HTMLElement | false;\n  types?: TypesetTypes;\n  doc?: TextDocument;\n  modules?: ModuleInitializers;\n  enabled?: boolean;\n  text?: string;\n  html?: string;\n  dev?: boolean;\n  throwOnError?: boolean;\n}\n\nexport interface Shortcuts {\n  [shortcut: string]: string;\n}\n\nexport interface Module {\n  init?: () => void;\n  destroy?: () => void;\n  shortcuts?: Shortcuts;\n  commands?: Commands;\n  getActive?: () => AttributeMap;\n  trimSelection?: (range:  EditorRange) => EditorRange;\n  [name: string]: any;\n}\n\nexport interface ModuleInitializers {\n  [name: string]: ModuleInitializer;\n}\n\nexport interface ModuleInitializer {\n  (editor: Editor): Module;\n}\n\nexport interface Modules {\n  [name: string]: Module;\n}\n\nexport interface EditorChangeEventInit extends EventInit {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n  source: SourceString;\n}\n\nexport class EditorChangeEvent extends Event {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n  source: SourceString;\n\n  constructor(type: string, init: EditorChangeEventInit) {\n    super(type, init);\n    this.old = init.old;\n    this.doc = init.doc;\n    this.change = init.change;\n    this.changedLines = init.changedLines;\n    this.source = init.source;\n    // Fix Safari bug, see https://stackoverflow.com/a/58471803\n    Object.setPrototypeOf(this, EditorChangeEvent.prototype);\n  }\n\n  // Modify the data during a \"changing\" event before doc is committed\n  modify(delta: Delta) {\n    if (!this.cancelable) throw new Error('Cannot modify an applied change, listen to the \"changing\" event');\n    this.doc = this.doc.apply(delta);\n    if (this.change) this.change.delta = this.change.delta.compose(delta);\n    if (this.changedLines) {\n      this.changedLines = this.old.lines === this.doc.lines ? EMPTY_ARR : getChangedLines(this.old, this.doc);\n    }\n  }\n}\n\nexport interface EditorFormatEventInit extends EventInit {\n  formats: AttributeMap;\n}\n\nexport class EditorFormatEvent extends Event {\n  formats: AttributeMap;\n\n  constructor(type: string, init: EditorFormatEventInit) {\n    super(type, init);\n    this.formats = init.formats;\n  }\n}\n\n\nexport default class Editor extends EventDispatcher {\n  identifier: any;\n  typeset: Typeset;\n  doc: TextDocument;\n  activeFormats: AttributeMap = EMPTY_OBJ;\n  commands: Commands = {};\n  shortcuts: Shortcuts = {};\n  modules: Modules = {};\n  catchErrors: boolean;\n  throwOnError: boolean;\n  _root!: HTMLElement;\n  private _modules: ModuleInitializers;\n  private _enabled: boolean;\n\n  constructor(options: EditorOptions = {}) {\n    super();\n    this.catchErrors = !options.dev;\n    this.identifier = options.identifier;\n    this.typeset = new Typeset(options.types || defaultTypes);\n    if (options.doc) {\n      this.doc = options.doc;\n    } else if (options.html) {\n      this.doc = docFromHTML(this, options.html);\n    } else if (options.text) {\n      this.doc = new TextDocument(new Delta().insert(options.text));\n    } else {\n      this.doc = new TextDocument();\n    }\n    this.throwOnError = options.throwOnError || false;\n    this._enabled = options.enabled === undefined ? true : options.enabled;\n    this._modules = { ...defaultModules, ...options.modules };\n    if (options.root) this.setRoot(options.root);\n  }\n\n  get root() {\n    if (!this._root) {\n      this.setRoot(document.createElement('div'));\n    }\n    return this._root;\n  }\n\n  get enabled() {\n    return this._enabled;\n  }\n\n  set enabled(value: boolean) {\n    value = !!value;\n    const changed = this._enabled !== value;\n    if (!value && this.doc.selection) this.select(null, Source.api);\n    this._enabled = value;\n    if (this._root) this._root.contentEditable = value ? 'true' : 'inherit';\n    if (changed) this.dispatchEvent(new Event('enabledchange'));\n  }\n\n  get change() {\n    const change = new TextChange(this.doc);\n    change.apply = (source: SourceString = Source.user) => this.update(change, source);\n    return change;\n  }\n\n  setRoot(root: HTMLElement): this {\n    if (!root) throw new TypeError('Root must be set, cannot be ' + root);\n    this.destroy();\n    this._root = root;\n    this.init();\n    this.dispatchEvent(new Event('root'));\n    return this;\n  }\n\n  update(changeOrDelta: TextChange | Delta, source: SourceString = Source.user): this {\n    if (!this.enabled && source !== Source.api) {\n      return this;\n    }\n    const change = (changeOrDelta as Delta).ops ? new TextChange(this.doc, changeOrDelta as Delta) : changeOrDelta as TextChange;\n    const old = this.doc;\n    const doc = old.apply(change as TextChange, undefined, this.throwOnError);\n    const changedLines = old.lines === doc.lines ? EMPTY_ARR : getChangedLines(old, doc);\n    this.set(doc, source, change, changedLines);\n    return this;\n  }\n\n  set(docOrDelta: TextDocument | Delta, source: SourceString = Source.user, change?: TextChange, changedLines?: Line[]): this {\n    const old = this.doc;\n    const doc = (docOrDelta as Delta).ops ? new TextDocument(docOrDelta as Delta) : docOrDelta as TextDocument;\n    if ((!this.enabled && source !== Source.api) || !doc || old.equals(doc)) {\n      return this;\n    }\n\n    const changingEvent = new EditorChangeEvent('changing', { cancelable: true, old, doc, change, changedLines, source });\n    this.dispatchEvent(changingEvent, this.catchErrors);\n    if (changingEvent.defaultPrevented || old.equals(changingEvent.doc)) return this;\n    this.activeFormats = change?.activeFormats ? change.activeFormats : getActiveFormats(this, changingEvent.doc);\n    this.doc = changingEvent.doc;\n    this.dispatchEvent(new EditorChangeEvent('change', { ...changingEvent, cancelable: false }), this.catchErrors);\n    this.dispatchEvent(new EditorChangeEvent('changed', { ...changingEvent, cancelable: false }), this.catchErrors);\n    return this;\n  }\n\n  getHTML(): string {\n    return docToHTML(this, this.doc);\n  }\n\n  setHTML(html: string, selection: EditorRange | null = this.doc.selection, source?: SourceString): this {\n    return this.set(docFromHTML(this, html, selection));\n  }\n\n  getDelta(): Delta {\n    return this.doc.toDelta();\n  }\n\n  setDelta(delta: Delta, selection: EditorRange | null = this.doc.selection, source?: SourceString): this {\n    return this.set(new TextDocument(delta, selection), source);\n  }\n\n  getText(range?: EditorRange): string {\n    return this.doc.getText(range);\n  }\n\n  setText(text: string, selection: EditorRange | null = this.doc.selection, source?: SourceString): this {\n    return this.set(new TextDocument(new Delta().insert(text), selection), source);\n  }\n\n  trimSelection(selection:  EditorRange): EditorRange {\n    if (!selection) return selection;\n    const selectedText = this.getText(selection);\n    const [ from, to ] = normalizeRange([ ...selection ]);\n    // don't trim if all spaces are selected\n    if (selectedText.trim()) {\n      const [ _, lead, text, tail ] = selectedText.match(/(^ *)((?:.|\\r|\\n)*?)( *$)/) as RegExpMatchArray;\n      if (text && (lead || tail)) {\n        return [ from + lead.length, to - tail.length ];\n      }\n    }\n    return selection;\n  }\n\n  getActive() {\n    const { selection } = this.doc;\n    let active = selection\n      ? selection[0] === selection[1]\n      ? { ...this.activeFormats, ...this.doc.getLineFormat(selection) }\n      : { ...this.doc.getFormats(selection) }\n      : {};\n    Object.values(this.modules).forEach(module => {\n      if (module.getActive) active = { ...active, ...module.getActive() };\n    });\n    return active;\n  }\n\n  select(at: EditorRange | number | null, source?: Source): this {\n    return this.update(this.change.select(at), source);\n  }\n\n  insert(insert: string | object, format?: AttributeMap, selection = this.doc.selection, options?: { dontFixNewline?: boolean }): this {\n    if (!selection) return this;\n    const inPlace = isEqual(selection, this.doc.selection);\n    if (format == null && typeof insert === 'string' && insert !== '\\n') {\n      format = inPlace ? this.activeFormats : getActiveFormats(this, this.doc, selection);\n    }\n    const type = this.typeset.lines.findByAttributes(format, true);\n    const change = this.change.delete(selection);\n    const at = normalizeRange(selection)[0];\n    if (inPlace) change.setActiveFormats(insert !== '\\n' && format || getActiveFormats(this, this.doc, selection));\n\n    if (insert === '\\n' && type.frozen) {\n      const lineFormat = { ...this.doc.getLineFormat(at) };\n      const secondLine = { ...format };\n      let lastLine = { ...lineFormat };\n      const newlines = new Delta()\n        .insert('\\n', lineFormat);\n      if (this.doc.getLineRange(at)[1] - 1 !== at) {\n        newlines.insert('\\n', secondLine);\n      } else {\n        lastLine = secondLine;\n      }\n      change.insertContent(at, newlines).formatLine(at, lastLine).select(at + 2);\n    } else {\n      change.insert(at, insert, format, options);\n    }\n    return this.update(change);\n  }\n\n  insertContent(content: Delta, selection = this.doc.selection): this {\n    if (!selection) return this;\n    const change = this.change\n      .delete(selection)\n      .insertContent(selection[0], content);\n    return this.update(change);\n  }\n\n  delete(directionOrSelection?: -1 | 1 | EditorRange, options?: { dontFixNewline?: boolean }): this {\n    let range: EditorRange;\n    if (Array.isArray(directionOrSelection)) {\n      range = normalizeRange(directionOrSelection);\n    } else {\n      if (!this.doc.selection) return this;\n      range = normalizeRange(this.doc.selection);\n      if (directionOrSelection && range[0] === range[1]) {\n        if (directionOrSelection < 0) range = [ range[0] + directionOrSelection, range[1] ];\n        else range = [ range[0], range[1] + directionOrSelection ];\n      }\n    }\n    const formats = getActiveFormats(this, this.doc, [ range[0] + 1, range[0] + 1 ]);\n    const change = this.change.delete(range, options).select(range[0]).setActiveFormats(formats);\n    return this.update(change);\n  }\n\n  formatText(format: AttributeMap | string, selection = this.doc.selection): this {\n    if (!selection) return this;\n    if (typeof format === 'string') format = { [format]: true };\n    if (selection[0] === selection[1]) {\n      this.activeFormats = AttributeMap.compose(this.activeFormats, format) || EMPTY_OBJ;\n      this.dispatchEvent(new EditorFormatEvent('format', { formats: this.activeFormats }));\n      return this;\n    }\n    changeFormat(this, 'formatText', format, selection);\n    return this;\n  }\n\n  toggleTextFormat(format: AttributeMap | 'string', selection = this.doc.selection): this {\n    if (!selection) return this;\n    if (typeof format === 'string') format = { [format]: true };\n    if (selection[0] === selection[1]) {\n      if (hasFormat(format, this.activeFormats)) format = AttributeMap.invert(format);\n      this.activeFormats = AttributeMap.compose(this.activeFormats, format) || EMPTY_OBJ;\n      this.dispatchEvent(new EditorFormatEvent('format', { formats: this.activeFormats }));\n      return this;\n    }\n    changeFormat(this, 'toggleTextFormat', format, selection);\n    return this;\n  }\n\n  formatLine(format: AttributeMap | string, selection: EditorRange | number | null = this.doc.selection): this {\n    if (typeof format === 'string') format = { [format]: true };\n    changeFormat(this, 'formatLine', format, selection);\n    return this;\n  }\n\n  toggleLineFormat(format: AttributeMap | string, selection = this.doc.selection): this {\n    if (typeof format === 'string') format = { [format]: true };\n    changeFormat(this, 'toggleLineFormat', format, selection);\n    return this;\n  }\n\n  indent(): this {\n    indentLines(this, 1);\n    return this;\n  }\n\n  outdent(): this {\n    indentLines(this, -1);\n    return this;\n  }\n\n  removeFormat(selection = this.doc.selection): this {\n    changeFormat(this, 'removeFormat', null, selection);\n    return this;\n  }\n\n  getBounds(range: EditorRange | number, relativeTo?: Element, relativeInside?: boolean): DOMRect | undefined {\n    if (typeof range === 'number') range = [ range, range ];\n    if (!range) return undefined;\n    let rect = getBoudingBrowserRange(this, range)?.getBoundingClientRect();\n    if (rect && relativeTo) {\n      const relative = relativeTo.getBoundingClientRect();\n      const leftOffset = (relativeInside ? relativeTo.scrollLeft : 0) - relative.x;\n      const topOffset = (relativeInside ? relativeTo.scrollTop : 0) - relative.y;\n      rect = new DOMRect(rect.x + leftOffset, rect.y + topOffset, rect.width, rect.height);\n    }\n    return rect;\n  }\n\n  getAllBounds(range: EditorRange | number, relativeTo?: Element, relativeInside?: boolean): DOMRect[] | undefined {\n    if (typeof range === 'number') range = [ range, range ];\n    const collection = getBoudingBrowserRange(this, range)?.getClientRects();\n    let list = collection && Array.from(collection);\n    if (list && relativeTo) {\n      const relative = relativeTo.getBoundingClientRect();\n      const leftOffset = (relativeInside ? relativeTo.scrollLeft : 0) - relative.x;\n      const topOffset = (relativeInside ? relativeTo.scrollTop : 0) - relative.y;\n      list = list.map(rect => new DOMRect(rect.x + leftOffset, rect.y + topOffset, rect.width, rect.height));\n    }\n    return list;\n  }\n\n  getIndexFromPoint(x: number, y: number) {\n    return getIndexFromPoint(this, x, y);\n  }\n\n  render(): this {\n    this.modules.decorations?.gatherDecorations();\n    this.modules.rendering?.render();\n    this.modules.selection?.renderSelection();\n    return this;\n  }\n\n  init() {\n    const root = this._root as any;\n    if (root.editor) root.editor.destroy();\n    root.editor = this;\n\n    this.enabled = this._enabled;\n    this.commands = {};\n    PROXIED_EVENTS.forEach(type => this._root.addEventListener(type, getEventProxy(this)));\n    this.typeset.lines.list.forEach(type => type.commands && mergeCommands(this, type.name, type.commands(this)));\n    this.typeset.formats.list.forEach(type => type.commands && mergeCommands(this, type.name, type.commands(this)));\n    this.typeset.embeds.list.forEach(type => type.commands && mergeCommands(this, type.name, type.commands(this)));\n    Object.keys(this._modules).forEach(key => {\n      if (!this._modules[key]) return;\n      const module = this.modules[key] = this._modules[key](this);\n      if (module.commands) mergeCommands(this, key, module.commands);\n    });\n    this.shortcuts = createShortcutMap(this);\n    Object.keys(this.modules).forEach(key => this.modules[key].init?.());\n    this.render();\n  }\n\n  destroy() {\n    const root = this._root as any;\n    if (!root) return;\n    PROXIED_EVENTS.forEach(type => root.removeEventListener(type, getEventProxy(this)));\n    Object.values(this.modules).forEach(module => module.destroy && module.destroy());\n    (this._root as any) = undefined;\n    delete root.editor;\n  }\n}\n\nfunction changeFormat(editor: Editor, op: string, format: AttributeMap | null, selection: EditorRange | number | null) {\n  if (!selection) return;\n  selection = typeof selection === 'number' ? [ selection, selection ] as EditorRange : editor?.trimSelection(selection);\n  const change = editor.change[op](selection, format);\n  editor.update(change);\n}\n\nfunction getActiveFormats(editor: Editor, doc: TextDocument, selection = doc.selection): AttributeMap {\n  const { formats } = editor.typeset;\n  if (!selection || selection[0] === 0) return EMPTY_OBJ;\n  const at = normalizeRange(selection)[0];\n  // If start of a non-empty line, use the format of the first character, otherwise use the format of the preceeding\n  let formatAt = at;\n  let formatTo = at + 1;\n  const attributes = doc.getTextFormat(formatAt);\n  const nextAttributes = doc.getTextFormat(formatTo);\n  const format: AttributeMap = {};\n  // Sort them by the order found in marks and be efficient\n  Object.keys(attributes).forEach(name => {\n    const type = formats.get(name);\n    if (type && type.greedy !== false) {\n      format[name] = attributes[name];\n    }\n  });\n  Object.keys(nextAttributes).forEach(name => {\n    const type = formats.get(name);\n    if (type && type.greedy === false) {\n      format[name] = attributes[name];\n    }\n  });\n  return format;\n}\n\nfunction getChangedLines(oldDoc: TextDocument, newDoc: TextDocument) {\n  const set = new Set(oldDoc.lines);\n  return newDoc.lines.filter(line => !set.has(line));\n}\n\nfunction mergeCommands(editor: Editor, name: string, other: Commands | Function) {\n  if (!other) return;\n  if (typeof other === 'function') editor.commands[name] = enhanceCommand(editor, other);\n  else Object.keys(other).forEach(key => editor.commands[key] = enhanceCommand(editor, other[key]));\n}\n\nfunction enhanceCommand(editor: Editor, command: Function) {\n  return (...args) => {\n    const result = command(...args);\n    if (editor.doc.selection) editor.root.focus();\n    return result;\n  }\n}\n\nfunction indentLines(editor: Editor, direction: 1 | -1 = 1) {\n  const { typeset: { lines }, doc } = editor;\n  const { selection } = doc;\n  if (!selection) return doc;\n  const change = editor.change;\n\n  doc.getLinesAt(selection).forEach(line => {\n    const type = lines.findByAttributes(line.attributes, true);\n    if (!type.indentable) return;\n    const range = doc.getLineRange(line);\n    let indent = (line.attributes.indent || 0) + direction;\n    if (indent <= 0) indent = null;\n    change.formatLine(range[0], indent < 0 ? EMPTY_OBJ : { ...line.attributes, indent });\n  });\n\n  editor.update(change);\n}\n\nfunction getEventProxy(editor: Editor) {\n  let proxy = eventProxies.get(editor);\n  if (!proxy) {\n    proxy = eventProxy.bind(editor);\n    eventProxies.set(editor, proxy);\n  }\n  return proxy;\n}\n\nfunction eventProxy(this: Editor, event: Event) {\n  this.dispatchEvent(event);\n}\n\nfunction createShortcutMap(editor: Editor): Shortcuts {\n  const all: Shortcuts = {};\n  const { typeset: { lines, formats, embeds }, modules } = editor;\n  mergeTypeShortcuts(lines, all);\n  mergeTypeShortcuts(formats, all);\n  mergeTypeShortcuts(embeds, all);\n  mergeModuleShortcuts(modules, all);\n  return all;\n}\n\nfunction mergeTypeShortcuts(types: Types, shortcuts: Shortcuts) {\n  types.list.forEach(type => {\n    const typeShortcuts = type.shortcuts;\n    if (!typeShortcuts) return;\n    if (typeof typeShortcuts === 'string') {\n      shortcuts[typeShortcuts] = type.name;\n    } else {\n      mergeShortcuts(typeShortcuts, shortcuts);\n    }\n  });\n}\n\nfunction mergeModuleShortcuts(modules: Modules, all: Shortcuts) {\n  Object.keys(modules).forEach(name => {\n    const shortcuts = modules[name]?.shortcuts;\n    if (shortcuts) mergeShortcuts(shortcuts, all);\n  });\n}\n\nfunction mergeShortcuts(shortcuts: Shortcuts, all: Shortcuts) {\n  Object.keys(shortcuts).forEach(shortcut => all[shortcut] = shortcuts[shortcut]);\n}\n","\nexport type SourceString = Source | string\n\nexport enum Source {\n  api = 'api',\n  user = 'user',\n  history = 'history',\n  input = 'input',\n  paste = 'paste'\n}\n","import Editor from '../Editor';\nimport { docToHTML, inlineToHTML } from '../rendering/html';\nimport { TextDocument, normalizeRange, EditorRange } from '@typewriter/document';\n\nconst defaultOptions: CopyOptions = {\n  copyPlainText: true,\n  copyHTML: true\n}\n\nexport interface CopyOptions {\n  copyPlainText?: boolean;\n  copyHTML?: boolean;\n}\n\nexport interface CopyData {\n  text?: string;\n  html?: string;\n  selection?: EditorRange | null;\n}\n\nconst empty = { text: '', html: '' };\n\nexport function copy(editor: Editor, options: CopyOptions = defaultOptions) {\n\n  function getCopy(selection?: EditorRange) {\n    const { doc } = editor;\n    const range = normalizeRange(selection || doc.selection as EditorRange);\n    if (!range) return empty;\n    const slice = doc.slice(range[0], range[1]);\n    if (!slice.ops.length) return empty;\n    const text = slice\n      .map(op => typeof op.insert === 'string' ? op.insert : ' ')\n      .join('');\n    let html: string;\n    if (text.includes('\\n')) {\n      slice.push({ insert: '\\n', attributes: doc.getLineFormat(range[1]) });\n      html = docToHTML(editor, new TextDocument(slice));\n    } else {\n      html = inlineToHTML(editor, slice);\n    }\n    return { text, html };\n  }\n\n  function onCopy(event: ClipboardEvent) {\n    if (!editor.enabled || !editor.doc.selection) return;\n    event.preventDefault();\n    const dataTransfer = event.clipboardData;\n    if (!dataTransfer) return;\n    const { text, html } = getCopy();\n    if (options.copyHTML && html) {\n      dataTransfer.setData('text/html', html);\n    }\n    if (options.copyPlainText && text) {\n      dataTransfer.setData('text/plain', text);\n    }\n  }\n\n  function onCut(event: ClipboardEvent) {\n    onCopy(event);\n    editor.delete();\n  }\n\n  return {\n    commands: {\n      getCopy,\n    },\n    init() {\n      editor.root.addEventListener('copy', onCopy);\n      editor.root.addEventListener('cut', onCut);\n    },\n    destroy() {\n      editor.root.removeEventListener('copy', onCopy);\n      editor.root.removeEventListener('cut', onCut);\n    }\n  }\n}\n","import { TextDocument, Line, EditorRange, TextChange  } from '@typewriter/document';\nimport { Delta, isEqual, AttributeMap} from '@typewriter/delta'\nimport Editor, { EditorChangeEvent } from '../Editor';\nimport { h, Props, VNode } from '../rendering/vdom';\nimport { EmbedType, FormatType } from '../typesetting';\n\nconst endInSemicolon = /;\\s*$/;\n\n\nconst formatDecoration: FormatType = {\n  name: 'decoration',\n  selector: 'span.format.decoration',\n  fromDom: false,\n  render: (attributes, children) => {\n    return applyDecorations(h('span', {}, children), attributes, [ 'format', 'decoration' ]);\n  }\n};\n\nconst embedDecoration: EmbedType = {\n  name: 'decoration',\n  selector: '.embed.decoration',\n  fromDom: false,\n  noFill: true,\n  render: (attributes, children) => {\n    const classes = 'embed decoration';\n    const { name: type, ...props } = attributes.decoration;\n    props.class = props.class ? classes + ' ' + props.class : classes;\n    return h(type || 'span', props, children);\n  }\n};\n\n\nexport interface Decorations {\n  class?: string;\n  style?: string;\n  [attributeName: string]: any;\n}\n\nexport interface DecorateEventInit extends EventInit {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n}\n\nexport class DecorateEvent extends Event {\n  old: TextDocument;\n  doc: TextDocument;\n  change?: TextChange;\n  changedLines?: Line[];\n\n  constructor(type: string, init: DecorateEventInit) {\n    super(type, init);\n    this.old = init.old;\n    this.doc = init.doc;\n    this.change = init.change;\n    this.changedLines = init.changedLines;\n  }\n}\n\nexport interface DecorationsModule {\n  readonly old: TextDocument;\n  readonly doc: TextDocument;\n  getDecorator: (name: string) => Decorator;\n  removeDecorations: (name: string) => boolean;\n  clearDecorations: () => void;\n  gatherDecorations: (change?: TextChange | undefined, changedLines?: Line[] | undefined) => void;\n  init(): void;\n  destroy(): void;\n}\n\n\nexport function decorations(editor: Editor): DecorationsModule {\n  editor.typeset.formats.add(formatDecoration);\n  editor.typeset.embeds.add(embedDecoration);\n\n  const decorations = new Map<string, Delta>();\n  let original = editor.doc;\n  let old = original;\n  let doc = original;\n  let decorating = false;\n\n  editor.on('change', onChange);\n  editor.on('render', onRender);\n\n\n  function getDecorator(name: string) {\n    if (!name) throw new TypeError('A decoration name is required');\n    const decoration = decorations.get(name);\n    return new Decorator(name, editor.doc, decoration, apply, removeDecorations);\n  }\n\n\n  function removeDecorations(name: string) {\n    if (!name) throw new TypeError('A decoration name is required');\n    const decoration = decorations.get(name);\n    if (!decoration) return false;\n\n    const inverted = invert(name, decoration, original);\n\n    decorations.delete(name);\n    if (!decorations.size) {\n      doc = original;\n    } else {\n      doc = doc.apply(inverted);\n    }\n\n    if (!decorating) {\n      editor.modules.rendering?.render({ old, doc });\n      editor.modules.selection?.renderSelection();\n    }\n\n    return true;\n  }\n\n\n  function clearDecorations() {\n    if (decorations.size) {\n      decorations.clear();\n    }\n    doc = original;\n  }\n\n\n  function apply(name: string, delta: Delta) {\n    const existing = decorations.get(name);\n    const decoration = existing ? existing.compose(delta, true) : delta;\n\n    if (isEqual(decoration, existing) || (!existing && !decoration.ops.length)) return;\n\n    if (!decoration.ops.length) {\n      decorations.delete(name);\n    } else {\n      decorations.set(name, decoration);\n    }\n\n    doc = decorations.size ? doc.apply(delta, null) : original;\n\n    if (!decorating) {\n      editor.modules.rendering?.render({ old, doc });\n      editor.modules.selection?.renderSelection();\n    }\n  }\n\n\n  function onChange(event: EditorChangeEvent) {\n    const { change, changedLines } = event;\n    original = event.doc;\n\n    if (change) {\n      if (change.contentChanged) {\n        for (let [ key, decoration ] of decorations) {\n          decoration = change.delta.transform(decoration, true);\n          if (decoration.ops.length) decorations.set(key, decoration);\n          else decorations.delete(key); // all content with decoration was deleted\n        }\n        doc = decorations.size ? doc.apply(change.delta, null) : original;\n\n        if (decorations.size) {\n          // Ensure the id of each line is the same\n          doc.lines.forEach((line, i) => {\n            const origLine = original.lines[i];\n            if (line !== origLine && line.id !== origLine.id) {\n              line.id = origLine.id;\n            }\n          })\n        }\n      }\n    } else {\n      clearDecorations();\n    }\n\n    gatherDecorations(change, changedLines);\n  }\n\n\n  function gatherDecorations(change?: TextChange, changedLines?: Line[]) {\n    const init: DecorateEventInit = { old, doc: original, change, changedLines };\n    decorating = true;\n    editor.dispatchEvent(new DecorateEvent('decorate', init));\n    decorating = false;\n  }\n\n\n  function onRender() {\n    old = doc; // Update old after a render\n  }\n\n\n  return {\n    get old() { return old },\n    get doc() { return doc },\n    getDecorator,\n    removeDecorations,\n    clearDecorations,\n    gatherDecorations,\n    init() {\n      gatherDecorations();\n    },\n    destroy() {\n      editor.off('change', onChange);\n      editor.off('render', onRender);\n    }\n  }\n}\n\n\n\nexport class Decorator {\n  change: TextChange;\n  private _name: string;\n  private _doc: TextDocument;\n  private _decoration: Delta | undefined;\n  private _apply: (name: string, updates: Delta) => void;\n  private _remove: (name: string) => void;\n\n  constructor(name: string, doc: TextDocument, decoration: Delta | undefined, apply: (name: string, updates: Delta) => void, remove: (name: string) => void) {\n    this._name = name;\n    this._doc = doc;\n    this.change = new TextChange(doc);\n    this._decoration = decoration;\n    this._apply = apply;\n    this._remove = remove;\n  }\n\n  hasDecorations() {\n    return !!this._decoration && this._decoration.ops.length > 0 || this.change.delta.ops.length > 0;\n  }\n\n  getDecoration() {\n    return this._decoration ? this._decoration.compose(this.change.delta) : this.change.delta;\n  }\n\n  apply() {\n    return this._apply(this._name, this.change.delta);\n  }\n\n  remove() {\n    return this._remove(this._name);\n  }\n\n  clear(range?: EditorRange) {\n    if (!this.hasDecorations()) return this;\n    if (!range) {\n      this.change.setDelta(this.invert());\n    } else {\n      this.change.setDelta(this.change.delta.compose(this.invert(range)));\n    }\n    return this;\n  }\n\n  clearLines(lines: Line[]) {\n    if (!lines.length) return this;\n    const doc = this._doc;\n    const range = [ doc.getLineRange(lines[0])[0], doc.getLineRange(lines[lines.length - 1])[1] ] as EditorRange;\n    const contiguous = lines.length === 1 || lines.every((line, i) =>\n      !i || doc.getLineRange(lines[i - 1])[1] === doc.getLineRange(line)[0]\n    );\n    if (contiguous) {\n      return this.clear(range);\n    }\n\n    const inverted = this.invert(range);\n    const delta = new Delta();\n    let pos = 0;\n    lines.forEach(line => {\n      const [ start, end ] = doc.getLineRange(line);\n      delta.retain(start - pos).concat(inverted.slice(start, end));\n      pos = end;\n    });\n    this.change.setDelta(this.change.delta.compose(delta));\n    return this;\n  }\n\n  // Clear line of these decorations at position, by id, or by instance\n  clearLine(value: number | string | Line) {\n    const doc = this._doc;\n    const line = typeof value === 'number'\n      ? doc.getLineAt(value)\n      : typeof value === 'string'\n      ? doc.getLineBy(value) as Line\n      : value;\n    return this.clearLines([ line ]);\n  }\n\n  invert(range?: EditorRange) {\n    if (!this._decoration) return new Delta();\n    return invert(this._name, this._decoration, this._doc, range);\n  }\n\n  decorateText(range: EditorRange, decoration: Decorations = { class: this._name }) {\n    this.change.formatText(range, { decoration: { [this._name]: decoration }});\n    return this;\n  }\n\n  decorateLine(range: EditorRange | number, decoration: Decorations = { class: this._name }) {\n    this.change.formatLine(range, { decoration: { [this._name]: decoration }}, true);\n    return this;\n  }\n\n  insertDecoration(at: number, decoration: Decorations = { class: this._name }) {\n    if (typeof decoration === 'string') {\n      throw new Error('You may only insert embed decorations');\n    }\n    this.change.insert(at, { decoration });\n    return this;\n  }\n}\n\nexport function applyDecorations(vnode: VNode, attributes: AttributeMap | undefined, defaultClasses?: string[]) {\n  if (!attributes || !attributes.decoration) return vnode;\n  const classes = new Set(defaultClasses);\n  let styles = '';\n  let props: Props = vnode.props;\n\n  Object.values(attributes.decoration).forEach((decorations: Decorations) => {\n    const { class: className, style, ...attributes } = decorations;\n    if (className) classes.add(className.trim());\n    if (style) styles += style.trim();\n    if (styles && !endInSemicolon.test(styles)) styles += ';';\n    props = { ...attributes, ...props };\n  });\n\n  const className = Array.from(classes).join(' ').trim();\n  if (className) props.class = props.class ? props.class + ' ' + className : className;\n  if (styles) props.style = props.style ? props.style + ';' + styles : styles;\n\n  vnode.props = props;\n\n  return vnode;\n}\n\n\nfunction invert(name: string, delta: Delta, doc: TextDocument, range?: EditorRange) {\n  let docDelta = doc.toDelta();\n  if (range) {\n    docDelta = docDelta.slice(range[0], range[1]);\n    delta = delta.slice(range[0], range[1]);\n  }\n  delta = delta.invert(docDelta);\n  delta.ops.forEach(op => {\n    if (op.attributes?.decoration === null) {\n      op.attributes.decoration = { [name]: null };\n    }\n  });\n  if (range) {\n    delta = new Delta().retain(range[0]).concat(delta);\n  }\n  return delta;\n}\n","import { decorations } from './decorations';\nimport { rendering } from './rendering';\nimport { keyboard } from './keyboard';\nimport { input } from './input';\nimport { selection } from './selection';\nimport { paste } from './paste';\nimport { copy } from './copy';\nimport { history } from './history';\n\nexport const defaultModules = { keyboard, input, copy, paste, history, decorations, rendering, selection };\n","import { TextDocument, TextChange, Delta } from '@typewriter/document';\nimport Editor, { EditorChangeEvent } from '../Editor';\nimport { Source } from '../Source';\n\nexport interface StackEntry {\n  redo: TextChange;\n  undo: TextChange;\n}\n\nexport interface UndoStack {\n  undo: StackEntry[],\n  redo: StackEntry[],\n}\n\nexport interface Options {\n  delay: number;\n  maxStack: number;\n}\n\n// Default history module\nexport const history = initHistory();\n\nexport interface HistoryModule {\n  options: Options;\n  hasUndo: () => boolean;\n  hasRedo: () => boolean;\n  undo: () => void;\n  redo: () => void;\n  cutoffHistory: () => void;\n  clearHistory: () => void;\n  setStack: (value: UndoStack) => void;\n  getStack: () => UndoStack;\n  destroy(): void;\n}\n\n/**\n * History is a view module for storing user changes and undoing/redoing those changes.\n *\n * Stores history for all user-generated changes. Like-changes will be combined until a selection or a delay timeout\n * cuts off the combining. E.g. if a user types \"Hello\" the 5 changes will be combined into one history entry. If\n * the user moves the cursor somewhere and then back to the end and types \" World\" the next 6 changes are combined\n * separately from the first 5 because selection changes add a cutoff history entries.\n *\n * The default options can be overridden by passing alternatives to history. To add a timeout to force a cutoff after\n * so many milliseconds set a delay like this:\n * ```js\n * const modules = {\n *   history: history({ delay: 4000 })\n * };\n * ```\n */\nexport function initHistory(initOptions: Partial<Options> = {}) {\n\n  return function(editor: Editor) {\n    let lastRecorded = 0;\n    let lastAction = '';\n    let ignoreChange = false;\n    let stack = undoStack();\n    const options: Options = { maxStack: 500, delay: 0, ...initOptions };\n\n    function onBeforeInput(event: InputEvent) {\n      if (event.inputType === 'historyUndo') {\n        event.preventDefault();\n        undo();\n      } else if (event.inputType === 'historyRedo') {\n        event.preventDefault();\n        redo();\n      }\n    }\n\n    function undo() {\n      action('undo', 'redo');\n    }\n\n    function redo() {\n      action('redo', 'undo');\n    }\n\n    function hasUndo() {\n      return stack.undo.length > 0;\n    }\n\n    function hasRedo() {\n      return stack.redo.length > 0;\n    }\n\n    function cutoffHistory() {\n      lastRecorded = 0;\n    }\n\n    function clearHistory() {\n      stack = undoStack();\n    }\n\n    function action(source: string, dest: string) {\n      if (stack[source].length === 0) return;\n      const entry = stack[source].pop();\n      stack[dest].push(entry);\n      cutoffHistory();\n      ignoreChange = true;\n      if (typeof entry[source] === 'function') {\n        entry[source]();\n      } else {\n        editor.update(entry[source], Source.history);\n      }\n      ignoreChange = false;\n    }\n\n\n    function record(change: TextChange, oldDoc: TextDocument) {\n      const timestamp = Date.now();\n      const action = getAction(change);\n      stack.redo.length = 0;\n\n      const undo = new TextChange(null, change.delta.invert(oldDoc.toDelta()), oldDoc.selection);\n\n      // Break combining if actions are different (e.g. a delete then an insert should break it)\n      if (!action || lastAction !== action) cutoffHistory();\n      lastAction = action;\n\n      if (lastRecorded && (!options.delay || lastRecorded + options.delay > timestamp) && stack.undo.length) {\n        // Combine with the last change\n        const entry = stack.undo[stack.undo.length - 1];\n        entry.redo.delta = entry.redo.delta.compose(change.delta);\n        entry.redo.selection = change.selection;\n        entry.undo.delta = undo.delta.compose(entry.undo.delta);\n      } else {\n        const redo = new TextChange(null, change.delta, change.selection);\n        lastRecorded = timestamp;\n        stack.undo.push({ redo, undo });\n      }\n\n      if (stack.undo.length > options.maxStack) {\n        stack.undo.shift();\n      }\n    }\n\n\n    function onChange({ change, old, source }: EditorChangeEvent) {\n      if (!change) return clearHistory();\n      if (ignoreChange) return;\n      if (!change.contentChanged) return cutoffHistory();\n      if (source !== Source.api) {\n        record(change, old);\n      } else {\n        transformHistoryStack(stack, change);\n      }\n    }\n\n    // Advanced, only use this if the stack matches the document\n    // e.g. use transformStack when changes come in for a document that isn't loaded\n    function setStack(value: UndoStack) {\n      stack = value;\n    }\n\n    function getStack() {\n      return stack;\n    }\n\n\n    return {\n      options,\n      hasUndo,\n      hasRedo,\n      undo,\n      redo,\n      cutoffHistory,\n      clearHistory,\n      setStack,\n      getStack,\n      getActive() {\n        return { undo: hasUndo(), redo: hasRedo() };\n      },\n      commands: {\n        undo,\n        redo,\n      },\n      shortcuts: {\n        'win:Ctrl+Z': 'undo',\n        'mac:Cmd+Z': 'undo',\n        'win:Ctrl+Y': 'redo',\n        'mac:Cmd+Shift+Z': 'redo',\n      },\n      init() {\n      editor.on('change', onChange);\n      editor.root.addEventListener('beforeinput', onBeforeInput);\n      },\n      destroy() {\n        editor.off('change', onChange);\n        editor.root.removeEventListener('beforeinput', onBeforeInput);\n      }\n    }\n  }\n}\n\nexport function undoStack(): UndoStack {\n  return {\n    undo: [],\n    redo: [],\n  };\n}\n\nexport function transformHistoryStack(stack: UndoStack, delta: TextChange | Delta) {\n  const change = (delta as Delta).ops ? new TextChange(null, delta as Delta) : delta as TextChange;\n\n  stack.undo.forEach(entry => {\n    entry.undo = change.transform(entry.undo, true);\n    entry.redo = change.transform(entry.redo, true);\n  });\n  stack.redo.forEach(entry => {\n    entry.undo = change.transform(entry.undo, true);\n    entry.redo = change.transform(entry.redo, true);\n  });\n}\n\nfunction getAction(change: TextChange) {\n  const { ops } = change.delta;\n  let head = 0, tail = ops.length - 1;\n  if (ops[head].retain && !ops[head].attributes) head++\n  if (ops[tail].retain === 1 && ops[tail].attributes?.id) tail--;\n  if (head === tail) {\n    const changeOp = ops[head];\n    if (changeOp.delete) return 'delete';\n    if (changeOp.insert === '\\n') return 'newline';\n    if (typeof changeOp.insert === 'string') return 'insert';\n  }\n  return '';\n}\n","import { AttributeMap, isEqual } from '@typewriter/document';\nimport Editor from '../Editor';\nimport { DecorateEvent, DecorationsModule, Decorations } from './decorations';\n\ninterface PlaceholderOptions {\n  keepAttribute?: boolean;\n}\n\n\n/**\n * Set placeholder text in the editable area when there is no content. Then add the css:\n *\n * ```css\n * .placeholder {\n *   position: relative;\n * }\n * .placeholder::before {\n *   content: attr(data-placeholder);\n *   position: absolute;\n *   left: 0;\n *   right: 0;\n *   opacity: 0.5;\n * }\n * ```\n */\nexport function placeholder(placeholder: string | Function, options?: PlaceholderOptions) {\n\n  return (editor: Editor) => {\n\n    function onDecorate({ doc }: DecorateEvent) {\n      const decorator = (editor.modules.decorations as DecorationsModule).getDecorator('placeholder');\n      const text = (typeof placeholder === 'function' ? placeholder() : placeholder) || '';\n      let lastDecorations: AttributeMap | undefined;\n\n      if (decorator.hasDecorations()) {\n        const ops = decorator.getDecoration().ops;\n        const last = ops[ops.length - 1];\n        lastDecorations = last.attributes?.decoration?.placeholder;\n      }\n\n      const { lines } = editor.typeset;\n      const type = lines.findByAttributes(doc.lines[0]?.attributes, true);\n      const showPlaceholder = lines.default === type && doc.length === 1;\n\n      if (showPlaceholder || options?.keepAttribute) {\n        const attributes: Decorations = { 'data-placeholder': text || '' };\n        if (showPlaceholder) attributes.class = 'placeholder';\n        if (!isEqual(attributes, lastDecorations)) {\n          decorator.remove();\n          decorator.decorateLine(0, attributes).apply();\n        }\n      } else {\n        decorator.remove();\n      }\n    }\n\n    editor.addEventListener('decorate', onDecorate);\n\n    return {\n      destroy() {\n        editor.removeEventListener('decorate', onDecorate);\n      }\n    }\n  }\n}\n","import { AttributeMap, Delta, Op } from '@typewriter/document';\nimport Editor, { EditorChangeEvent } from '../Editor';\n\nconst straitQuotes = /['\"]/g;\nconst nonchar = /[\\s\\{\\[\\(\\<'\"\\u2018\\u201C]/;\nconst conversions = {\n  '\"': { left: '', right: '' },\n  \"'\": { left: '', right: '' },\n}\n\n/**\n * Replaces regular quotes with smart quotes as they are typed. Also affects pasted content.\n * Uses the text-changing event to prevent the original change and replace it with the new one. This makes the smart-\n * quotes act more seemlessly and includes them as part of regular text undo/redo instead of breaking it like the smart-\n * entry conversions do.\n */\nexport function smartQuotes(editor: Editor) {\n\n  function onTextChange(event: EditorChangeEvent) {\n    const { change, source, doc, old } = event;\n    if (source === 'api' || !old.selection || !change) return;\n\n    const indices = getQuoteIndices(change.delta.ops);\n    if (!indices.length) return;\n\n    const text = doc.getText();\n    const convert = new Delta();\n    let pos = 0;\n\n    for (let i = 0; i < indices.length; i++) {\n      const [ index, attributes ] = indices[i];\n      const quote = text[index] as '\"' | \"'\";\n      const converted = !index || nonchar.test(text[index - 1]) ? conversions[quote].left : conversions[quote].right;\n      convert.retain(index - pos).delete(1).insert(converted, attributes);\n      pos = index + 1;\n    }\n    event.modify(convert);\n  }\n\n  editor.on('changing', onTextChange);\n\n  return {\n    destroy() {\n      editor.off('changing', onTextChange);\n    }\n  }\n}\n\nfunction getQuoteIndices(ops: Op[]) {\n  const indices: Array<[number, AttributeMap | undefined]> = [];\n  let pos = 0;\n  ops.forEach(op => {\n    if (op.retain) pos += op.retain;\n    else if (typeof op.insert === 'string') {\n      let result: RegExpExecArray | null;\n      while ((result = straitQuotes.exec(op.insert))) {\n        indices.push([ pos + result.index, op.attributes ]);\n      }\n      pos += op.insert.length;\n    } else if (op.insert) {\n      pos += 1;\n    } // Delete shouldn't change anything\n  });\n  return indices;\n}\n","import { AttributeMap, Delta } from '@typewriter/document';\nimport Editor, { EditorChangeEvent } from '../Editor';\n\n\nexport type Replacement = [RegExp, (captured: string) => AttributeMap];\nexport type TextReplacement = [RegExp, (captured: string) => string];\nconst httpExpr = /(https?:\\/\\/.)[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b[-a-zA-Z0-9@:%_+.~#?&/=]*\\s$/s;\nconst wwwExpr = /(www\\.)[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b[-a-zA-Z0-9@:%_+.~#?&/=]*\\s$/s;\nconst nakedExpr = /[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.(com|org|net|io)\\b[-a-zA-Z0-9@:%_+.~#?&/=]*\\s$/s;\n\nexport type Handler = (editor?: Editor, index?: number, prefix?: string, wholeText?: string) => void;\n\n/**\n * A list of [ RegExp, Function ] tuples to convert text into a formatted line with the attributes returned by the\n * function. The function's argument will be the captured text from the regular expression.\n */\nexport const lineReplacements: Replacement[] = [\n  [ /^(#{1,6}) $/, capture => ({ header: capture.length }) ],\n  [ /^[-*] $/, () => ({ list: 'bullet' }) ],\n  [ /^1\\. $/, () => ({ list: 'ordered' }) ],\n  [ /^([AaIi])\\. $/, type => ({ list: 'ordered', type }) ],\n  [ /^(-?\\d+)\\. $/, start => ({ list: 'ordered', start }) ], // Use /^(-?\\d+)\\. $/ to support lists starting at something other than 1.\n  [ /^([A-Z])\\. $/, char => ({ list: 'ordered', type: 'A', start: char.charCodeAt(0) - 'A'.charCodeAt(0) + 1 }) ],\n  [ /^([a-z])\\. $/, char => ({ list: 'ordered', type: 'a', start: char.charCodeAt(0) - 'a'.charCodeAt(0) + 1 }) ],\n  [ /^([IVXLCDM]+)\\. $/i, chars => ({ list: 'ordered', type: chars[0].toUpperCase() === chars[0] ? 'I' : 'i', start: fromRomanNumeral(chars) }) ],\n  [ /^> $/, () => ({ blockquote: true }) ],\n];\n\n/**\n * A list of [ RegExp, Function ] tuples to convert text into formatted text with the attributes returned by the\n * function. The function's argument will be the captured text from the regular expression.\n */\nexport const markReplacements: Replacement[] = [\n  [ /(\\*|_){3}(\\b(?:(?!\\1).)+\\b)\\1{3}((?:(?!\\1).))$/s, () => ({ bold: true, italic: true })],\n  [ /(\\*|_){2}(\\b(?:(?!\\1).)+\\b)\\1{2}((?:(?!\\1).))$/s, () => ({ bold: true })],\n  [ /(\\*|_){1}(\\b(?:(?!\\1).)+\\b)\\1{1}((?:(?!\\1).))$/s, () => ({ italic: true })],\n];\n\nexport const linkReplacements: Replacement[] = [\n  [ httpExpr, capture => ({ link: capture }) ],\n  [ wwwExpr, capture => ({ link: 'https://' + capture }) ],\n  [ nakedExpr, capture => ({ link: 'https://' + capture }) ],\n];\n\n/**\n * A list of [ RegExp, Function ] tuples to convert text into another string of text which is returned by the function.\n * The function's argument will be the captured text from the regular expression.\n */\nexport const textReplacements: TextReplacement[] = [\n  [ /--$/, () => '' ],\n  [ /\\.\\.\\.$/, () => '' ],\n];\n\n/**\n * Allow text representations to format a line\n */\nexport function lineReplace(editor: Editor, index: number, prefix: string) {\n  return lineReplacements.some(([ regexp, getAttributes ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      const attributes = getAttributes(match[1]);\n      if (!editor.typeset.lines.findByAttributes(attributes)) {\n        return false;\n      }\n      const start = index - prefix.length;\n      const change = editor.change\n        .delete([ start, index ])\n        .formatLine(index, attributes)\n        .select([ start, start ]);\n      editor.update(change);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport function linkReplace(editor: Editor, index: number, prefix: string) {\n  return linkReplacements.some(([ regexp, getAttributes ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      let text = match[0].slice(0, -1);\n      if (text[text.length - 1] === '.') text = text.slice(0, -1);\n      const end = index - (match[0].length - text.length);\n      const attributes = getAttributes(text);\n      if (!editor.typeset.formats.findByAttributes(attributes)) {\n        return false;\n      }\n      editor.formatText(attributes, [ end - text.length, end ]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport function markReplace(editor: Editor, index: number, prefix: string, wholeText: string) {\n  return markReplacements.some(([ regexp, getAttributes ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      let [ text, _, matched, last ] = match;\n      const attributes = getAttributes(matched);\n      if (!editor.typeset.formats.findByAttributes(attributes)) {\n        return false;\n      }\n      let selection = index - (text.length - matched.length) + last.length;\n      if (last === ' ' && wholeText[index] === ' ') last = '';\n      const end = index - last.length;\n      editor.insert(matched, attributes, [ end - text.length + last.length, end ]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport function textReplace(editor: Editor, index: number, prefix: string) {\n  return textReplacements.some(([ regexp, replaceWith ]) => {\n    const match = prefix.match(regexp);\n    if (match) {\n      editor.insert(replaceWith(match[1]), undefined, [ index - match[0].length, index ]);\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexport const defaultHandlers = [ lineReplace, textReplace, linkReplace ];\n\n\nexport function smartEntry(handlers: Handler[] = defaultHandlers) {\n\n  return (editor: Editor) => {\n    let ignore = false;\n\n    function onTextChange({ change, source }: EditorChangeEvent) {\n      if (ignore || source === 'api' || !editor.doc.selection || !change || !isTextEntry(change.delta)) return;\n      const index = editor.doc.selection[1];\n      const text = editor.doc.getText();\n      const lineStart = text.lastIndexOf('\\n', index - 2) + 1;\n      const prefix = text.slice(lineStart, index);\n\n      ignore = true;\n      handlers.some(handler => handler(editor, index, prefix, text));\n      ignore = false;\n    }\n\n    editor.on('changed', onTextChange);\n\n    return {\n      destroy() {\n        editor.off('changed', onTextChange);\n      }\n    }\n  };\n}\n\n\nfunction isTextEntry(change: Delta) {\n  return (\n    change.ops.length === 1 ||\n    (change.ops.length === 2 && change.ops[0].retain && !change.ops[0].attributes)\n  ) &&\n    change.ops[change.ops.length - 1].insert// &&\n    // change.ops[change.ops.length - 1].insert !== '\\n';\n}\n\nconst DIGIT_VALUES = {\n  I: 1,\n  V: 5,\n  X: 10,\n  L: 50,\n  C: 100,\n  D: 500,\n  M: 1000\n};\n\ntype RomanNumeral = keyof typeof DIGIT_VALUES;\n\nfunction fromRomanNumeral(romanNumeral: string): number | undefined {\n  romanNumeral = romanNumeral.toUpperCase();\n  let result = 0;\n  for (let i = 0; i < romanNumeral.length; i++) {\n    const currentLetter = DIGIT_VALUES[romanNumeral[i] as RomanNumeral];\n    const nextLetter = DIGIT_VALUES[romanNumeral[i + 1] as RomanNumeral];\n    if (currentLetter === undefined) return undefined;\n    if (currentLetter < nextLetter) {\n      result += nextLetter - currentLetter;\n      i++;\n    } else {\n      result += currentLetter;\n    }\n  };\n\n  return result;\n}\n","import Editor from '../Editor';\nimport { Delta, TextChange, normalizeRange, diff } from '@typewriter/document';\nimport { deltaFromDom } from '../rendering/html';\nimport { getLineNodeEnd, getLineNodeStart, HTMLLineElement } from '../rendering/rendering';\nimport { getSelection } from '../rendering/selection';\nimport { getIndexFromNode } from '../rendering/position';\nimport { cleanText } from '../rendering/html';\nimport { Source } from '../Source';\n\nconst isIPad = navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform);\nconst isIOS = isIPad || /iPad|iPhone|iPod/.test(navigator.userAgent) && !(window as any).MSStream;\nconst isAndroid = !isIOS && /Mobi|Android/.test(navigator.userAgent) && !(window as any).MSStream;\n\n\nconst MUTATION_OPTIONS = {\n  characterData: true,\n  characterDataOldValue: true,\n  subtree: true,\n  childList: true\n};\n\ntype HTMLLineRange = [HTMLLineElement, HTMLLineElement];\n\nexport function input(editor: Editor) {\n  let gboardEnter = false;\n  // Browsers have had issues in the past with mutation observers firing consistently, so use the observer with the input\n  // event as fallback\n  function onInput() {\n    const mutations = observer.takeRecords();\n    if (mutations.length) onMutate(mutations);\n  }\n\n  // for Gboard fix -- checks if start of line is an insert br\n  function isBr(change: Delta) {\n    let isBr = false;\n    const lastOp = change.ops[change.ops.length - 1];\n    if (lastOp.insert) {\n      const insert = lastOp.insert as any;\n      if (insert.br) {\n        isBr = true;\n      }\n    }\n    return isBr;\n  }\n\n  // Final fallback. Handles composition text etc. Detects text changes from e.g. spell-check or Opt+E to produce\n  function onMutate(list: MutationRecord[]) {\n    if (!editor.enabled) {\n      return editor.render();\n    }\n\n    // Optimize for text changes (typing text)\n    let change = getTextChange(list) as Delta;\n    let selection = getSelection(editor);\n\n    if (!change) {\n      const range = getChangedLineRange(editor.root, list);\n      change = getChangeFromRange(range);\n    }\n\n    // Gboard fix to move to next line\n    if (gboardEnter) {\n      // Sometimes gBoard adds a br instead of a new line (seen with h2)\n      if (isBr(change)) {\n        change.ops.pop();\n        change.insert('\\n');\n      }\n\n      // advance to next line\n      if (selection !== null) {\n        selection[0]++;\n        selection[1]++;\n      }\n      gboardEnter = false;\n    }\n\n    if (change && change.ops.length) {\n      cleanText(change);\n      const old = editor.doc;\n      editor.update(new TextChange(editor.doc, change, selection, editor.activeFormats), Source.input);\n      if (editor.doc.lines === old.lines) {\n        editor.render();\n      }\n    }\n  }\n\n  function getTextChange(list: MutationRecord[]): Delta | null {\n    const mutation = getTextChangeMutation(list);\n    if (!mutation || mutation.oldValue == null || mutation.target.nodeValue == null) return null;\n\n    const change = new Delta();\n    const index = getIndexFromNode(editor, mutation.target);\n    change.retain(index);\n\n    let relativeEditLocation: undefined | number = undefined;\n    if (editor.doc.selection) {\n      const selection = normalizeRange(editor.doc.selection);\n      relativeEditLocation = selection[0] - index;\n\n      if (relativeEditLocation < 0) {\n        relativeEditLocation = 0;\n      }\n    }\n\n    const diffs = diff(mutation.oldValue.replace(/\\xA0/g, ' '), mutation.target.nodeValue.replace(/\\xA0/g, ' '), relativeEditLocation);\n    diffs.forEach(([ action, string ]) => {\n      if (action === diff.EQUAL) change.retain(string.length);\n      else if (action === diff.DELETE) change.delete(string.length);\n      else if (action === diff.INSERT) {\n        change.insert(string, editor.activeFormats);\n      }\n    });\n    change.chop();\n    return change;\n  }\n\n  // Fallback to commit whatever was changed, least performant\n  function getChangeFromRange(range?: HTMLLineRange) {\n    const { doc } = editor;\n    if (range) {\n      const [ startNode, endNode ] = range;\n      const start = getLineNodeStart(editor.root, startNode);\n      const end = getLineNodeEnd(editor.root, endNode);\n      const delta = deltaFromDom(editor, { startNode, endNode: endNode.nextElementSibling || undefined, collapseWhitespace: false });\n      let change = doc.toDelta().slice(start, end).diff(delta);\n      if (change.ops.length && start) change = new Delta().retain(start).concat(change);\n      return change;\n    } else {\n      const delta = deltaFromDom(editor, { collapseWhitespace: false });\n      return doc.toDelta().diff(delta);\n    }\n  }\n\n\n  const observer = new window.MutationObserver(onMutate);\n\n  // Don't observe the changes that occur when the view updates, we only want to respond to changes that happen\n  // outside of our API to read them back in\n  function onRendering() {\n    observer.disconnect();\n  }\n\n  function onRender() {\n    observer.observe(editor.root, MUTATION_OPTIONS);\n  }\n\n  // Function to detect if Gboard is sending new lines with composed input\n  function onBeforeInput(event: InputEvent) {\n    if (! event.data) return;\n    if (event.data.includes('\\n')) {\n      gboardEnter = true;\n    }\n  }\n\n  return {\n    init() {\n      editor.root.addEventListener('input', onInput);\n      editor.on('rendering', onRendering);\n      editor.on('render', onRender);\n      if (isAndroid) {\n        editor.root.addEventListener('beforeinput', onBeforeInput); // needed for Gboard fix\n      }\n    },\n    destroy() {\n      observer.disconnect();\n      editor.root.removeEventListener('input', onInput);\n      editor.off('rendering', onRendering);\n      editor.off('render', onRender);\n      if (isAndroid) {\n        editor.root.removeEventListener('beforeinput', onBeforeInput); // gboard fix\n      }\n    }\n  }\n}\n\nfunction getTextChangeMutation(list: MutationRecord[]) {\n  // Shrink the list down to one entry per text node\n  const textNodes = new Set();\n  list = list.filter(record => {\n    if (record.type !== 'characterData') return true;\n    if (textNodes.has(record.target)) return false;\n    textNodes.add(record.target);\n    return true;\n  });\n\n  if (list.length > 3) return null;\n\n  const text = list.find(record => record.type === 'characterData');\n  if (!text) return null;\n  const textAdd = list.find(record => record.addedNodes.length === 1 && record.addedNodes[0].nodeName === '#text');\n  const brAddRemove = list.find(record => {\n    return (record.addedNodes.length === 1 && record.addedNodes[0].nodeName === 'BR') ||\n           (record.removedNodes.length === 1 && record.removedNodes[0].nodeName === 'BR');\n  });\n  const count = 1 + (textAdd ? 1 : 0) + (brAddRemove ? 1 : 0);\n  if (count < list.length) return null;\n  if (textAdd && textAdd.addedNodes[0] !== text.target) return null;\n  return text;\n}\n\n\nfunction getChangedLineRange(root: HTMLElement, records: MutationRecord[]): HTMLLineRange | undefined {\n  let start: HTMLLineElement | undefined, end: HTMLLineElement | undefined;\n\n  for (let i = 0; i < records.length; i++) {\n    const record = records[i];\n    if (record.target === root) return; // line added/removed\n\n    const line = getTopLine(root, record.target);\n    if (line && line.key) {\n      if (!start || getLineNodeStart(root, line) < getLineNodeStart(root, start)) start = line;\n      if (!end || getLineNodeStart(root, line) > getLineNodeStart(root, end)) end = line;\n    } else {\n      // If a line is deleted or new line added we will return null and diff the whole thing (rare fallback case)\n      return;\n    }\n  }\n\n  if (start && end) return [ start, end ];\n}\n\nfunction getTopLine(root: HTMLElement, node: any) {\n  while (node && node.parentNode !== root) node = node.parentNode;\n  return node as HTMLLineElement | null;\n}\n","import Editor from '../Editor';\nimport { addShortcutsToEvent, KeyboardEventWithShortcut, ShortcutEvent } from './shortcutFromEvent';\nimport { Line, normalizeRange } from '@typewriter/document';\nimport { Source } from '../Source';\n\n\n// A list of bad characters that we don't want coming in from pasted content (e.g. \"\\f\" aka line feed)\nconst EMPTY_OBJ = {};\nconst IS_CHROME = (window as any).chrome && typeof (window as any).chrome === 'object';\n\n// Basic keyboard module.\nexport function keyboard(editor: Editor) {\n\n\n  function onEnter(event: KeyboardEvent) {\n    if (event.defaultPrevented) return;\n\n    const { typeset: { lines }, doc } = editor;\n    let { selection } = doc;\n\n    if (!selection) return;\n    event.preventDefault();\n    const [ at, to ] = selection;\n    const isCollapsed = at === to;\n\n    const line = doc.getLineAt(selection[0]);\n    const [ start, end ] = doc.getLineRange(selection[0]);\n\n    let { id, ...attributes } = line.attributes;\n    let options: { dontFixNewline?: boolean } | undefined;\n    const type = lines.findByAttributes(attributes, true);\n    const atStart = to === start;\n    const atEnd = to === end - 1;\n\n    if (isEmpty(line) && type !== lines.default && !type.contained && !type.defaultFollows && !type.frozen && isCollapsed) {\n      // Convert a bullet point into a paragraph\n      editor.formatLine(EMPTY_OBJ);\n    } else {\n      if (at === start && to === end && type.frozen) {\n        options = { dontFixNewline: true };\n        if (at === 0) {\n          // if single selection and line element (hr, image etc) insert new line before\n          selection = [ at, at ];\n        } else {\n          selection = [ to, to ];\n        }\n        attributes = type.nextLineAttributes ? type.nextLineAttributes(attributes) : EMPTY_OBJ;\n      } else if (atEnd && (type.nextLineAttributes || type.defaultFollows || type.frozen)) {\n        attributes = type.nextLineAttributes ? type.nextLineAttributes(attributes) : EMPTY_OBJ;\n      } else if (atStart && !atEnd) {\n        if (type.defaultFollows) attributes = EMPTY_OBJ;\n        options = { dontFixNewline: true };\n      }\n      editor.insert('\\n', attributes, selection, options);\n      if (at === start && to === end && type.frozen) {\n        editor.select(at === 0 ? 0 : to);\n      }\n    }\n  }\n\n\n  function onShiftEnter(event: KeyboardEvent) {\n    if (event.defaultPrevented) return;\n    const { typeset, doc } = editor;\n    if (!typeset.embeds.get('br')) return onEnter(event);\n    if (!doc.selection) return;\n    event.preventDefault();\n    editor.insert({ br: true });\n  }\n\n\n  function onBackspace(event: KeyboardEvent) {\n    handleDelete(event, -1);\n  }\n\n\n  function onDelete(event: KeyboardEvent) {\n    handleDelete(event, 1);\n  }\n\n\n  function handleDelete(event: KeyboardEvent, direction: 1 | -1) {\n    if (event.defaultPrevented) return;\n    const { typeset: { lines }, doc } = editor;\n    const { selection } = doc;\n    if (!selection) return;\n    const [ at, to ] = selection;\n    const isCollapsed = at === to;\n    const [ start, end ] = doc.getLineRange(at);\n\n    // Allow the system to handle non-line-collapsing deletes\n    // (Bug in Chrome where backspace at the end of a span can delete an entire paragraph)\n    if (isCollapsed && (!IS_CHROME || event.ctrlKey || event.altKey || event.metaKey)) {\n      if (direction === -1 && at !== start) return;\n      if (direction === 1 && at !== end - 1) return;\n    }\n\n    event.preventDefault();\n\n    if (direction === -1 && selection[0] + selection[1] === 0) {\n      // At the beginning of the document\n      unindent(doc.getLineAt(at), true);\n    } else {\n      const range = normalizeRange(selection);\n      const line = doc.getLineAt(range[0]);\n      const type = lines.findByAttributes(line.attributes, true);\n      // If the deletion will move outside a line (collapsing 2 lines)\n      const outside = isCollapsed && ((direction === -1 && at === start) || (direction === 1 && at === end - 1));\n\n      if (outside && !type.contained) {\n        // At the beginning of a line\n        if (direction === -1 && unindent(doc.getLineAt(at))) return;\n\n        // Delete the next line if it is empty\n        const mergingLine = doc.lines[doc.lines.indexOf(line) + direction];\n        const [ first, second ] = direction === 1 ? [ line, mergingLine] : [ mergingLine, line ];\n        if (first && isEmpty(first) && second && !isEmpty(second)) {\n          return editor.update(\n            editor.change.delete([ range[0] + direction, range[0] ], { dontFixNewline: true }),\n            Source.input\n          );\n        }\n      }\n\n      editor.delete(direction, { dontFixNewline: type.frozen });\n    }\n\n\n    function unindent(line: Line, force?: boolean) {\n      if (!line) return;\n      const type = lines.findByAttributes(line.attributes, true);\n      if (!type) return;\n      if (type.indentable && line.attributes.indent) {\n        editor.outdent();\n        return true;\n      }\n      if (force || type !== lines.default && !type.defaultFollows) {\n        editor.formatLine(EMPTY_OBJ);\n        return true;\n      }\n    }\n  }\n\n\n  function onTab(event: KeyboardEventWithShortcut) {\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    const shortcut = event.modShortcut;\n    if (shortcut === 'Tab' || shortcut === 'Mod+]') editor.indent();\n    else editor.outdent();\n  }\n\n\n\n  function onKeyDown(event: KeyboardEventWithShortcut) {\n    if (event.isComposing) return;\n\n    addShortcutsToEvent(event);\n\n    const checkShortcut = shortcut => {\n      const command = editor.shortcuts[shortcut];\n      if (command && editor.commands[command]) {\n        event.preventDefault();\n        return editor.commands[command]() !== false;\n      }\n    }\n\n    if (\n      !editor.root.dispatchEvent(ShortcutEvent.fromKeyboardEvent(event))\n      || checkShortcut(event.shortcut)\n      || checkShortcut(event.osShortcut)\n      || checkShortcut(event.modShortcut)\n    ) {\n      event.preventDefault();\n      return;\n    }\n\n    switch (event.modShortcut) {\n      case 'Enter': return onEnter(event);\n      case 'Shift+Enter': return onShiftEnter(event);\n      case 'Tab':\n      case 'Shift+Tab':\n      case 'Mod+]':\n      case 'Mod+[': return onTab(event);\n    }\n\n    switch (event.modShortcut?.split('+').pop()) {\n      case 'Backspace': return onBackspace(event);\n      case 'Delete': return onDelete(event);\n      default: return;\n    }\n  }\n\n  function isEmpty(line: Line) {\n    return line.length === 1 && !editor.typeset.lines.findByAttributes(line.attributes)?.frozen;\n  }\n\n  return {\n    init() {\n      editor.root.addEventListener('keydown', onKeyDown);\n    },\n    destroy() {\n      editor.root.removeEventListener('keydown', onKeyDown);\n    }\n  }\n}\n","import { Delta, Line, normalizeRange, isEqual, EditorRange } from '@typewriter/document';\nimport Editor from '../Editor';\nimport { deltaFromHTML } from '../rendering/html';\nimport { Source } from '../Source';\n\nconst dontFixNewline = { dontFixNewline: true };\nconst ignoreId = { excludeProps: new Set([ 'id' ]) };\n\nexport interface PasteEventInit extends EventInit {\n  delta: Delta;\n  html?: string;\n  text?: string;\n}\n\nexport class PasteEvent extends Event {\n  delta: Delta;\n  html?: string;\n  text?: string;\n\n  constructor(type: string, init: PasteEventInit) {\n    super(type, init);\n    this.delta = init.delta;\n    this.html = init.html;\n    this.text = init.text;\n  }\n}\n\nexport interface PasteOptions {\n  text?: string;\n  html?: string;\n  selection?: EditorRange | null;\n}\n\nexport interface PasteOptions {\n  htmlParser?: (editor: Editor, html: string) => Delta;\n}\n\nexport function paste(editor: Editor, options?: PasteOptions) {\n\n  function paste({ selection, text, html }: PasteOptions) {\n    const { doc } = editor;\n    selection = selection || doc.selection;\n    selection = selection && normalizeRange(selection);\n    if (!selection) return;\n    const [ at, to ] = selection;\n    let delta: Delta;\n    if (!html) {\n      if (!text) return;\n      delta = new Delta().insert(text.replace(/\\xA0/g, ' ').replace(/\\r\\n/g, '\\n'));\n    } else if (options?.htmlParser) {\n      delta = options.htmlParser(editor, html);\n    } else {\n      delta = deltaFromHTML(editor, html, { possiblePartial: true });\n    }\n\n    const hasLines = delta.filter(op => typeof op.insert === 'string' && op.insert.includes('\\n')).length > 0;\n    let length = delta.length();\n\n    if (hasLines) {\n      // check the boundaries to see if they can be merged with the current line or need to make a new line\n      let lines = Line.fromDelta(delta, doc.byId);\n      delta = Line.toDelta(lines);\n      length = delta.length();\n\n      const startLine = doc.getLineAt(at);\n      const endLine = doc.getLineAt(to);\n      const startAttrs = getAttributes(startLine);\n      const endAttrs = startLine === endLine ? startAttrs : getAttributes(endLine);\n\n      // plain text should merge better with the existing content\n      if (!html) {\n        lines = lines.map(line => ({ ...line, attributes: startLine.attributes }));\n        if (startAttrs !== endAttrs) lines[lines.length - 1].attributes = endLine.attributes;\n      }\n\n      const pastedStartLine = lines[0];\n      const pastedStartAttrs = getAttributes(pastedStartLine);\n      const pastedEndLine = lines[lines.length - 1];\n      const pastedEndAttrs = pastedStartLine === pastedEndLine ? pastedStartAttrs : getAttributes(pastedEndLine);\n\n      if (at !== doc.getLineRange(startLine)[0] && !isEqual(startAttrs, pastedStartAttrs, ignoreId)) {\n        delta = new Delta().insert('\\n', startAttrs).concat(delta);\n        length++;\n      }\n\n      const lastInsert = delta.ops[delta.ops.length - 1].insert;\n      const endsInNewline = typeof lastInsert === 'string' && lastInsert.endsWith('\\n');\n\n      // Does the last line of a multi-line paste merge with the last line?\n      if (endsInNewline && to !== doc.getLineRange(endLine)[1] && isEqual(endAttrs, pastedEndAttrs, ignoreId)) {\n        // Remove the trailing newline to merge with the last line\n        delta = delta.slice(0, --length);\n      // If a multi-line paste is inserted at the end of a line, delete the line's newline and let the inserted one take\n      } else if (endsInNewline && to === doc.getLineRange(endLine)[1] - 1) {\n        delta.delete(1);\n        length--;\n      }\n    }\n\n    const viewEvent = new PasteEvent('paste', { delta, html, text, cancelable: true });\n    editor.dispatchEvent(viewEvent);\n    delta = viewEvent.delta;\n\n    if (!viewEvent.defaultPrevented) {\n      if (delta && delta.ops.length) {\n        const change = editor.change.delete(selection, hasLines ? dontFixNewline : undefined);\n        change.insertContent(at, delta).select(at + length);\n        editor.update(change, Source.paste);\n      } else if (at !== to) {\n        editor.delete([ at, to ]);\n      }\n    }\n  }\n\n  function onPaste(event: ClipboardEvent) {\n    if (!editor.enabled || !editor.doc.selection) return;\n    event.preventDefault();\n    const dataTransfer = event.clipboardData;\n    const { doc } = editor;\n    if (!dataTransfer || !doc.selection) return;\n    const html = dataTransfer.getData('text/html');\n    const text = dataTransfer.getData('text/plain');\n    paste({ text, html });\n  }\n\n  return {\n    commands: {\n      paste,\n    },\n    init() {\n      editor.root.addEventListener('paste', onPaste);\n    },\n    destroy() {\n      editor.root.removeEventListener('paste', onPaste);\n    }\n  }\n}\n\nfunction getAttributes(line: Line) {\n  const { id, ...attributes } = line.attributes;\n  return attributes;\n}\n","import Editor, { EditorChangeEvent } from '../Editor';\nimport { TextDocument } from '@typewriter/document';\nimport { render as renderWhole, renderChanges } from '../rendering/rendering';\n\n\nexport interface RenderWhat {\n  old?: TextDocument;\n  doc?: TextDocument;\n}\n\n\nexport function rendering(editor: Editor) {\n\n  editor.on('change', onChange);\n\n  function render(what?: RenderWhat) {\n    if (!what) {\n      const { doc } = editor.modules.decorations as { doc: TextDocument } || editor;\n      renderWhole(editor, doc);\n    } else {\n      const { doc, old } = what;\n      if (old && doc) {\n        renderChanges(editor, old, doc);\n      } else if (doc) {\n        renderWhole(editor, doc);\n      }\n    }\n  }\n\n\n  function onChange(event: EditorChangeEvent) {\n    const { doc, old } = editor.modules.decorations as { old: TextDocument, doc: TextDocument } || event;\n    if (old.lines !== doc.lines) {\n      renderChanges(editor, old, doc);\n    }\n  }\n\n\n  return {\n    render,\n    destroy() {\n      editor.off('change', onChange);\n    }\n  }\n}\n","import { isEqual } from '@typewriter/document';\nimport Editor, { EditorChangeEvent } from '../Editor';\nimport { getSelection, setSelection } from '../rendering/selection';\nimport { getLineNodeStart } from '../rendering/rendering';\nimport { DecorationsModule } from './decorations';\n\n\nexport function selection(editor: Editor) {\n  let rootDocument: Document;\n  let rootWindow: Window;\n  let paused = false;\n\n  function onSelectionChange() {\n    if (!editor.enabled) return;\n    const selection = getSelection(editor);\n    if (!selection && paused) return;\n    if (paused) paused = false;\n    if (selection && selection[0] === selection[1] && editor.doc.selection && editor.doc.selection[0] === selection[0] && editor.doc.selection[1] === selection[0] + 1) {\n      // Allow a frozen line (e.g. hr) to move the cursor left with a left arrow key\n      const line = editor.doc.getLineAt(selection[0]);\n      const type = editor.typeset.lines.findByAttributes(line.attributes, true);\n      if (type.frozen) {\n        selection[0]--;\n        selection[1]--;\n      }\n    }\n    const { doc } = editor;\n    if (!isEqual(doc.selection, selection)) {\n      if (selection && selection[0] === selection[1] && selection[0] >= doc.length) {\n        return; // Assuming this is a text composition at the end of the document, allow the entry\n      }\n      editor.select(selection);\n    }\n  }\n\n  function renderSelection() {\n    if (paused || !editor.enabled) return;\n    setSelection(editor, editor.doc.selection);\n  }\n\n  function onDecorate() {\n    const { doc, typeset: { lines }} = editor;\n    const decorator = (editor.modules.decorations as DecorationsModule).getDecorator('selection');\n    decorator.clear();\n    const selection = doc.selection;\n    if (selection) {\n      doc.getLinesAt(selection).forEach(line => {\n        if (lines.findByAttributes(line.attributes, true).frozen) {\n          const focused = isEqual(selection, doc.getLineRange(line));\n          decorator.decorateLine(doc.getLineRange(line)[0], { class: 'selected' + (focused ? ' focus' : '') });\n        }\n      });\n    }\n    decorator.apply();\n  }\n\n  function onMouseDown(event: MouseEvent) {\n    // Helps select lines that are not easily selectable (e.g. <hr>)\n    let node = event.target as Node;\n    while (node.parentNode && node.parentNode !== editor.root) node = node.parentNode;\n    const start = getLineNodeStart(editor.root, node);\n    const line = start != null && editor.doc.getLineAt(start);\n    const type = line && editor.typeset.lines.findByAttributes(line.attributes);\n    if (start != null && line && type && type.frozen) {\n      event.preventDefault();\n      editor.select([ start, start + line.length ]);\n    }\n  }\n\n  function onChange(event: EditorChangeEvent) {\n    const selection = event.doc?.selection || editor.doc.selection;\n    setSelection(editor, selection);\n  }\n\n  function onWindowFocus() {\n    editor.root.classList.toggle('window-inactive', !rootDocument.hasFocus());\n  }\n\n  function pause() {\n    paused = true;\n    const { selection } = editor.doc;\n    const { decorations } = editor.modules as {decorations: DecorationsModule}\n    if (selection && selection[0] !== selection[1] && decorations) {\n      const decorator = decorations.getDecorator('pausedSelection');\n      decorator.decorateText(selection, { class: 'selected' }).apply();\n    }\n  }\n\n  function resume() {\n    paused = false;\n    const { decorations } = editor.modules as {decorations: DecorationsModule}\n    if (decorations) {\n      decorations.removeDecorations('pausedSelection');\n    }\n    setTimeout(renderSelection);\n  }\n\n  return {\n    pause,\n    resume,\n    renderSelection,\n    init() {\n      rootDocument = editor.root.ownerDocument;\n      rootWindow = rootDocument.defaultView as Window;\n\n      rootDocument.addEventListener('selectionchange', onSelectionChange);\n      rootWindow.addEventListener('focus', onWindowFocus);\n      rootWindow.addEventListener('blur', onWindowFocus);\n      editor.root.addEventListener('mousedown', onMouseDown);\n      editor.on('change', onChange);\n      editor.on('decorate', onDecorate);\n    },\n    destroy() {\n      rootDocument.removeEventListener('selectionchange', onSelectionChange);\n      rootWindow.removeEventListener('focus', onWindowFocus);\n      rootWindow.removeEventListener('blur', onWindowFocus);\n      editor.root.removeEventListener('mousedown', onMouseDown);\n      editor.off('change', onChange);\n      editor.off('decorate', onDecorate);\n      paused = false;\n      rootDocument = null as any;\n      rootWindow = null as any;\n    }\n  }\n};\n","const modifierKeys = {\n  Control: true,\n  Meta: true,\n  Shift: true,\n  Alt: true\n};\nconst isMac = navigator.userAgent.indexOf('Macintosh') !== -1;\nconst modExpr = isMac ? /Cmd/ : /Ctrl/;\n\n\nexport interface ShortcutEventInit extends KeyboardEventInit {\n  shortcut?: string;\n}\n\nexport class ShortcutEvent extends KeyboardEvent {\n  readonly shortcut: string;\n  readonly osShortcut: string;\n  readonly modShortcut: string;\n\n  constructor(type: string, init?: ShortcutEventInit) {\n    super(type, init);\n    this.shortcut = init?.shortcut || '';\n    this.osShortcut = `${isMac ? 'mac' : 'win'}:${this.shortcut}`;\n    this.modShortcut = this.shortcut.replace(modExpr, 'Mod');\n  }\n\n  static fromKeyboardEvent(event: KeyboardEvent) {\n    (event as KeyboardEventWithShortcut).shortcut = shortcutFromEvent(event);\n    return new ShortcutEvent('shortcut', event);\n  }\n}\n\nexport interface KeyboardEventWithShortcut extends KeyboardEvent {\n  shortcut?: string;\n  osShortcut?: string;\n  modShortcut?: string;\n}\n\nexport function addShortcutsToEvent(event: KeyboardEventWithShortcut) {\n  event.shortcut = shortcutFromEvent(event);\n  event.osShortcut = `${isMac ? 'mac' : 'win'}:${event.shortcut}`;\n  event.modShortcut = event.shortcut.replace(modExpr, 'Mod');\n  return event;\n}\n\n/**\n * Returns the textual representation of a shortcut given a keyboard event. Examples of shortcuts:\n * Cmd+L\n * Cmd+Shift+M\n * Ctrl+O\n * Backspace\n * T\n * Right\n * Shift+Down\n * Shift+F1\n * Space\n */\nexport function shortcutFromEvent(event) {\n  const shortcutArray: string[] = [];\n  let key = event.key;\n  if (!key) return '';\n  if (key === ' ') key = 'Space';\n\n  if (event.metaKey) shortcutArray.push('Cmd');\n  if (event.ctrlKey) shortcutArray.push('Ctrl');\n  if (event.altKey) shortcutArray.push('Alt');\n  if (event.shiftKey) shortcutArray.push('Shift');\n\n  if (!modifierKeys[key]) {\n    if (isMac && event.altKey && event.code && event.code.startsWith('Key')) {\n      // The altKey on mac can change the key value (e.g. Cmd+Alt+R will show up as Cmd+Alt+ if we don't do this)\n      key = event.code.replace('Key', '');\n    }\n    // a and A, b and B, should be the same shortcut\n\n    if (key.length === 1) key = key.toUpperCase();\n    shortcutArray.push(key);\n  }\n\n  return shortcutArray.join('+');\n}\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\nconst matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nexport function escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","import { TextDocument, Delta, EditorRange, Line } from '@typewriter/document';\nimport { escapeHtml } from './escape-html';\nimport { VChild } from './vdom';\nimport { HTMLLineElement, renderInline } from '../rendering/rendering';\nimport { createTreeWalker } from './walker';\nimport { renderDoc } from './rendering';\nimport Editor from '../Editor';\n\n// A list of bad characters that we don't want coming in from pasted content (e.g. \"\\f\" aka line feed)\nexport const BLOCK_ELEMENTS = 'address, article, aside, blockquote, editor, dd, div, dl, dt, fieldset, figcaption, figure, footer, form, h1, h2, h3, h4, h5, h6, header, hr, li, main, nav, noscript, ol, output, p, pre, section, table, tfoot, ul, video';\nconst BAD_CHARS = /[\\0-\\x09\\x0B\\x1F\\x7F-\\x9F\\xAD\\u0600-\\u0605\\u061C\\u06DD\\u070F\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u2064\\u2066-\\u206F\\uFEFF\\uFFF9-\\uFFFB\\uE000-\\uF8FF]/g;\nconst SKIP_ELEMENTS = { STYLE: true, SCRIPT: true, LINK: true, META: true, TITLE: true, };\nconst VOID_ELEMENTS = {\n  area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true,\n  link: true, meta: true, param: true, source: true, track: true, wbr: true\n};\nconst whitespaceExp = /[ \\t\\n\\r]+/g;\nconst textsNode = document.createElement('div');\nconst defaultOptions = {};\n\nexport interface DeltaFromHTMLOptions {\n  possiblePartial?: boolean;\n  collapseWhitespace?: boolean;\n}\n\nexport interface FromDomOptions {\n  root?: HTMLElement;\n  startNode?: Node;\n  endNode?: Node;\n  offset?: number;\n  possiblePartial?: boolean;\n  includeIds?: boolean;\n  collapseWhitespace?: boolean;\n}\n\n\n// Determines if a <br> in the editable area is part of the document or a doorstop at the end of a line.\nexport function isBRPlaceholder(editor: Editor, node: Node) {\n  if (node.nodeName !== 'BR') return false;\n  return isLastNode(editor, node);\n}\n\n// Check if this is the last node (not counting empty text nodes)\nfunction isLastNode(editor: Editor, node: Node) {\n  const containingLine = (node as Element).closest && (node as Element).closest(editor.typeset.lines.selector);\n  if (!containingLine) return false;\n  const walker = createTreeWalker(containingLine);\n  walker.currentNode = node;\n  const next = walker.nextNode();\n  return !next || next instanceof HTMLElement && next.matches(BLOCK_ELEMENTS);\n}\n\n\nexport function docToHTML(editor: Editor, doc: TextDocument) {\n  return childrenToHTML(renderDoc(editor, doc, true));\n}\n\n\nexport function inlineToHTML(editor: Editor, delta: Delta) {\n  return childrenToHTML(renderInline(editor, delta, true));\n}\n\n\nexport function docFromHTML(editor: Editor, html: string, selection?: EditorRange | null) {\n  return new TextDocument(deltaFromHTML(editor, html), selection);\n}\n\n\nexport function deltaFromHTML(editor: Editor, html: string, options?: DeltaFromHTMLOptions) {\n  const parser = new window.DOMParser();\n  const doc = parser.parseFromString(html, 'text/html' );\n  const delta = deltaFromDom(editor, {\n    root: doc.body,\n    possiblePartial: options?.possiblePartial,\n    collapseWhitespace: options?.collapseWhitespace\n  });\n  cleanText(delta);\n  return delta;\n}\n\n\nexport function docFromDom(editor: Editor, root: HTMLElement) {\n  return new TextDocument(deltaFromDom(editor, { root }));\n}\n\n// Return a line or multi-line array from the top-level node\nexport function fromNode(editor: Editor, dom: HTMLElement) {\n  const lines = Line.fromDelta(deltaFromDom(editor, { root: dom }), editor.doc.byId);\n  if (!lines.length) return;\n  const type = editor.typeset.lines.findByAttributes(lines[0].attributes, true);\n  if (type.renderMultiple) return lines;\n  return lines[0];\n}\n\n\nexport function cleanText(delta: Delta) {\n  delta.forEach(op => {\n    if (typeof op.insert === 'string') {\n      op.insert = op.insert.replace(BAD_CHARS, '');\n    }\n  });\n}\n\n\nexport function deltaFromDom(editor: Editor, options: FromDomOptions = defaultOptions): Delta {\n  const { lines, embeds } = editor.typeset;\n  const root = options.root || editor.root;\n\n  const collapseWhitespace = options.collapseWhitespace != undefined ? options.collapseWhitespace : true\n\n  var walker = createTreeWalker(root, node => !SKIP_ELEMENTS[node.nodeName]);\n  const delta = new Delta();\n  let currentLine: any, firstLineSeen = false, unknownLine = false, empty = true, node: Node | null;\n\n  if (options.startNode) {\n    walker.currentNode = options.startNode;\n    walker.previousNode();\n    if (options.offset) delta.retain(options.offset, undefined);\n  } else {\n    walker.currentNode = root;\n  }\n\n  while ((node = walker.nextNode())) {\n    if (node === options.endNode) break;\n\n    if (isBRPlaceholder(editor, node)) {\n      empty = false;\n    } else if (node.nodeName === 'BR' && (node as Element).className === 'Apple-interchange-newline') {\n      delta.insert('\\n', !currentLine || currentLine.unknownLine ? {} : currentLine);\n    } else if (node.nodeType === Node.TEXT_NODE) {\n      let parent = node.parentNode as Element;\n\n      // If all newlines, we can ignore\n      if (node.nodeValue == null || node.nodeValue.replace(/\\n+/g, '') === '') continue;\n\n      // If blank text between lines, ignore\n      if (!node.nodeValue.replace(/\\s+/g, '')) {\n        if (node.parentNode === root\n          || (node.previousSibling && lines.matches(node.previousSibling))\n          || (node.nextSibling && lines.matches(node.nextSibling))) {\n            continue;\n          }\n      }\n\n      const nodeText = node.nodeValue\n      // optionally collapse whitespace (the default)\n      const filteredWhitespace = collapseWhitespace ? nodeText.replace(whitespaceExp, ' ') : nodeText\n      // non-breaking spaces (&nbsp;) are spaces\n      const text = filteredWhitespace.replace(/\\xA0/g, ' ');\n\n      // Word gives us end-of-paragraph nodes with a single space. Ignore them.\n      if (!text || (text === ' ' && parent.classList.contains('EOP'))) continue;\n\n      // Gather up all the formats for this text node, walking up to the line level\n      const attributes = gatherFormats(parent, root, editor);\n\n      empty = false;\n      delta.insert(text, attributes);\n    } else if (embeds.matches(node)) {\n      const embed = embeds.findByNode(node);\n      if (embed) {\n        const attributes = gatherFormats(node.parentNode as Element, root, editor);\n        if (embed.fromDom !== false) {\n          delta.insert(embed.fromDom ? embed.fromDom(node) : { [embed.name]: true }, attributes);\n        }\n      }\n    } else if (lines.matches(node) || (node.nodeType === Node.ELEMENT_NODE && (node as Element).matches(BLOCK_ELEMENTS))) {\n      unknownLine = !lines.matches(node);\n\n      if (unknownLine) {\n        let parent = node.parentNode;\n        while (parent && !lines.matches(parent) && parent !== root) {\n          parent = parent.parentNode;\n        }\n        // If this line element is inside a recognized line, ignore it\n        if (parent && parent !== root) {\n          continue;\n        }\n      }\n\n      const line = lines.findByNode(node, true);\n\n      // Skip paragraphs/divs inside blockquotes and list items etc.\n      if (line === lines.default && (!node.parentNode || lines.matches(node.parentNode))) {\n        continue;\n      }\n\n      // Ensure next iteration skips any internal nodes in a frozen line\n      if (line.frozen) {\n        // Skip to the last child in this node so that .nextNode() will move on to outside this frozen line\n        while (walker.lastChild());\n      }\n\n      if (firstLineSeen) {\n        if (!currentLine || !currentLine.unknownLine || !empty) {\n          delta.insert('\\n', !currentLine || currentLine.unknownLine ? {} : currentLine);\n          empty = true;\n        }\n      } else {\n        firstLineSeen = true;\n      }\n\n      if (unknownLine) {\n        currentLine = { unknownLine };\n      } else if (line && line !== lines.default) {\n        currentLine = line.fromDom ? line.fromDom(node) : { [line.name]: true };\n      } else {\n        currentLine = {};\n      }\n      if (options.includeIds && (node as HTMLLineElement).key) {\n        currentLine.id = (node as HTMLLineElement).key;\n      }\n    }\n  }\n\n  // Delta documents should always end with a newline, unless they are partial documents\n  if (!unknownLine || !empty) {\n    if (firstLineSeen || !options.possiblePartial) {\n      delta.insert('\\n', !currentLine || currentLine.unknownLine ? {} : currentLine);\n    }\n  }\n\n  return delta;\n}\n\n\n// vdom children to HTML string\nfunction childrenToHTML(children: VChild[]): string {\n  if (!children || !children.length) return '';\n  return (children as any).reduce((html: string, child: VChild) => html + (typeof child !== 'string' ? nodeToHTML(child) : escapeHtml(child).replace(/\\xA0/g, '&nbsp;')), '');\n}\n\n// vdom node to HTML string\nfunction nodeToHTML(node: VChild): string {\n  if (typeof node === 'string') {\n    textsNode.textContent = node;\n    const html = textsNode.innerHTML;\n    textsNode.textContent = '';\n    return html;\n  }\n  const attr = Object.keys(node.props)\n    .reduce((attr, name) =>\n      name === 'key' || node.props[name] == null\n      ? attr\n      : `${attr} ${escapeHtml(name)}=\"${escapeHtml(node.props[name])}\"`, '');\n  const children = childrenToHTML(node.children);\n  const closingTag = children || !VOID_ELEMENTS[node.type] ? `</${node.type}>` : '';\n  return `<${node.type}${attr}>${children}${closingTag}`;\n}\n\n\n// Walk up the DOM to the closest parent, finding formats\nfunction gatherFormats(parent: Element, root: Element, editor: Editor) {\n  const { lines, formats } = editor.typeset;\n  const attributes = {};\n\n  while (parent && !lines.matches(parent) && parent !== root) {\n    if (formats.matches(parent)) {\n      const format = formats.findByNode(parent);\n      if (format && format.fromDom !== false) {\n        attributes[format.name] = format.fromDom ? format.fromDom(parent) : true;\n      }\n    } else if (parent.hasAttribute('style')) {\n      formats.list.forEach(format => {\n        if (format.styleSelector && parent.matches(format.styleSelector)) {\n          attributes[format.name] = format.fromDom ? format.fromDom(parent) : true;\n        }\n      });\n    }\n    parent = parent.parentNode as Element;\n  }\n\n  return attributes;\n}\n","import Editor from '../Editor';\nimport { getLineNodeEnd, getLineNodeStart, HTMLLineElement } from './rendering';\nimport { EditorRange, Line } from '@typewriter/document';\nimport { isBRPlaceholder } from './html';\nimport { createTreeWalker } from './walker';\nimport { Types } from '../typesetting';\n\n\ntype NodeAndOffset = [Node | null, number];\ntype NodeOffsetAndFrozen = [Node | null, number, boolean?];\n\nconst EMPTY_NODE_OFFSET: NodeAndOffset = [ null, 0 ];\n\n\nexport interface LineInfo {\n  line: Line;\n  element: HTMLLineElement;\n  rect: DOMRect;\n  belowMid: boolean;\n}\n\n\nexport function getIndexFromPoint(editor: Editor, x: number, y: number) {\n  const document = editor.root.ownerDocument\n  if ('caretPositionFromPoint' in document) {\n    try {\n      const pos = (document as any).caretPositionFromPoint(x, y);\n      if (pos) {\n        return getIndexFromNodeAndOffset(editor, pos.offsetNode, pos.offset);\n      }\n    } catch (_) {}\n  }\n\n  if (document.caretRangeFromPoint) {\n    const range = document.caretRangeFromPoint(x, y) as Range;\n    if (range) {\n      return getIndexFromNodeAndOffset(editor, range.startContainer, range.startOffset);\n    }\n  }\n\n  return null;\n}\n\n// Return the line that matches a point and true if the point comes after the midpoint of the line display\nexport function getLineInfoFromPoint(editor: Editor, y: number): LineInfo | undefined {\n  const { root } = editor;\n  if (!root.ownerDocument) return;\n  const lineElements = Array.from(root.querySelectorAll(editor.typeset.lines.selector))\n    .filter(elem => (elem as any).key) as HTMLLineElement[];\n  const last = lineElements[lineElements.length - 1];\n  for (const element of lineElements) {\n    const rect = element.getBoundingClientRect();\n    if (rect.bottom >= y || element === last) {\n      const line = editor.doc.getLineBy(element.key);\n      return { line, element, rect, belowMid: y > rect.top + rect.height/2 };\n    }\n  }\n}\n\n\n// Get a browser range object for the given editor range tuple\nexport function getBrowserRange(editor: Editor, range: EditorRange) {\n  if (range[0] > range[1]) range = [ range[1], range[0] ];\n  const [ anchorNode, anchorOffset, focusNode, focusOffset ] = getNodesForRange(editor, range);\n  const browserRange = editor.root.ownerDocument.createRange();\n  if (anchorNode && focusNode) {\n    browserRange.setStart(anchorNode, anchorOffset);\n    browserRange.setEnd(focusNode, focusOffset);\n  }\n  return browserRange;\n}\n\n\nexport function getBoudingBrowserRange(editor: Editor, range: EditorRange): Range {\n  const browserRange = getBrowserRange(editor, range);\n  if (browserRange?.endContainer.nodeType === Node.ELEMENT_NODE) {\n    try {\n      browserRange.setEnd(browserRange.endContainer, browserRange.endOffset + 1);\n    } catch(e) {}\n  }\n  return browserRange;\n}\n\n\nexport function getIndexFromNodeAndOffset(editor: Editor, node: Node, offset: number, current?: number | null): number {\n  const { root } = editor;\n  const { lines } = editor.typeset;\n  if (!root.contains(node)) {\n    return -1;\n  }\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    if (node.childNodes.length === offset) {\n      if (getLineNodeEnd(root, node) != null) return getLineNodeEnd(root, node) - 1;\n      if (node.childNodes.length) {\n        node = node.childNodes[offset - 1];\n        offset = getNodeLength(editor, node);\n      }\n    } else {\n      node = node.childNodes[offset];\n      offset = 0;\n    }\n    const start = getLineNodeStart(root, node);\n    if (start != null) {\n      // If the node is frozen, we are getting the index of the start of the node (e.g. <hr>)\n      if (lines.findByNode(node)?.frozen) {\n        return start + offset;\n      }\n      // Otherwise the selection fell between line nodes, if we came from before, we will go inside, if we came from inside, we will skip to before\n      return (current == null || current < start ? start : start - 1) + offset;\n    }\n  }\n  return getIndexFromNode(editor, node) + offset;\n}\n\n\n// Get the index the node starts at in the content\nexport function getIndexFromNode(editor: Editor, startNode: Node): number {\n  const { root } = editor;\n  if (!root.ownerDocument) return -1;\n  const { lines, embeds } = editor.typeset;\n  const walker = createTreeWalker(root);\n\n  walker.currentNode = startNode;\n  let node: Node | null;\n  let index = 0;\n  let start: number | undefined;\n  while ((node = walker.previousNode())) {\n    if (node === root) break;\n    else if ((start = getLineNodeStart(root, node)) != null) {\n      index += start;\n      break;\n    } else if (node.nodeType === Node.TEXT_NODE) index += textNodeLength(lines, node);\n    else if ((node as HTMLElement).classList?.contains('decoration')) index;\n    else if (embeds.matches(node) && !isBRPlaceholder(editor, node as HTMLElement)) index++;\n    else if (lines.matches(node) && editor.doc.lines[0].id !== (node as any).key) index++;\n  }\n  return index;\n}\n\n\nexport function getLineElementAt(editor: Editor, index: number) {\n  const { root } = editor;\n  if (!root.ownerDocument) return;\n  const childNodes = Array.from(root.childNodes);\n  return childNodes.find((line: HTMLLineElement) =>\n    getLineNodeStart(root, line) <= index && getLineNodeEnd(root, line) > index\n  ) as HTMLLineElement;\n}\n\n\nexport function getNodeLength(editor: Editor, parentNode: Node): number {\n  const { lines, embeds } = editor.typeset;\n  if (embeds.matches(parentNode) && !isBRPlaceholder(editor, parentNode as HTMLElement)) {\n    return 1;\n  }\n\n  if (parentNode.nodeType === Node.TEXT_NODE) return textNodeLength(lines, parentNode);\n\n  const walker = createTreeWalker(parentNode);\n  let length = lines.findByNode(parentNode) ? 1 : 0, node: Node | null;\n  while (node = walker.nextNode()) {\n    if (node.nodeType === Node.TEXT_NODE) length += textNodeLength(lines, node);\n    else if ((node as HTMLElement).classList?.contains('decoration')) length;\n    else if (embeds.matches(node) && !isBRPlaceholder(editor, node as HTMLElement)) length++;\n    else if (lines.matches(node)) length++;\n  }\n  return length;\n}\n\n\n// Get the browser nodes and offsets for the range (a tuple of indexes) of this view\nexport function getNodesForRange(editor: Editor, range: EditorRange): [Node | null, number, Node | null, number] {\n  if (range == null) {\n    return [ null, 0, null, 0 ];\n  } else {\n    const anchorFirst = range[0] <= range[1];\n    const direction = anchorFirst ? 1 : -1;\n    const isCollapsed = range[0] === range[1];\n    const [ anchorNode, anchorOffset, frozen ] = getNodeAndOffset(editor, range[0], anchorFirst ? 0 : 1);\n    const [ focusNode, focusOffset ] = isCollapsed && !frozen\n      ? [ anchorNode, anchorOffset ]\n      : frozen && (isCollapsed || range[1] - range[0] === direction * editor.doc.getLineAt(range[0]).length)\n      ? [ anchorNode, anchorOffset + (anchorFirst ? 1 : -1) ]\n      : getNodeAndOffset(editor, range[1], anchorFirst ? 1 : 0);\n\n    return [ anchorNode, anchorOffset, focusNode, focusOffset ];\n  }\n}\n\n\nexport function getNodeAndOffset(editor: Editor, index: number, direction: 0 | 1): NodeOffsetAndFrozen {\n  const { root } = editor;\n  if (!root.ownerDocument) return EMPTY_NODE_OFFSET;\n  const { lines, embeds } = editor.typeset;\n\n  const childNodes = Array.from(root.childNodes);\n  const line = getLineElementAt(editor, index);\n  if (!line) return EMPTY_NODE_OFFSET;\n\n  const type = lines.findByNode(line, true);\n  if (type.frozen) {\n    return [ line.parentNode, childNodes.indexOf(line) + direction, true ]\n  }\n\n  index -= getLineNodeStart(root, line);\n  const atStart = !index;\n\n  const walker = createTreeWalker(line);\n\n  let node: Node | null, firstLineSeen = false;\n  while ((node = walker.nextNode())) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      const size = textNodeLength(lines, node);\n      if (index <= size) return [ node, index ];\n      index -= size;\n    } else if ((node as HTMLElement).classList?.contains('decoration')) {\n    } else if (embeds.matches(node) && !isBRPlaceholder(editor, node as HTMLElement)) {\n      const embed = embeds.findByNode(node);\n      if (!embed || embed.fromDom === false) {\n        continue;\n      }\n      index -= 1;\n      // If the selection lands after this embed, and the next node isn't a text node, place the selection\n      if (index <= 0) {\n        const children = Array.from((node.parentNode as HTMLElement).childNodes) as Node[];\n        return [ node.parentNode, children.indexOf(node) + 1 + index ];\n      }\n    } else if (lines.matches(node)) {\n      if (firstLineSeen) index -= 1;\n      else firstLineSeen = true;\n\n      // If the selection lands at the beginning of a line, and the first node isn't a text node, place the selection\n      if (index === 0) {\n        const first = walker.firstChild();\n        if (first && first.nodeType === Node.TEXT_NODE) {\n          return [ first, 0 ];\n        } else if (first) {\n          const children = Array.from(node.childNodes) as Node[];\n          return [ node, children.indexOf(first) ];\n        } else {\n          return [ node, 0 ];\n        }\n      }\n    }\n  }\n  return atStart ? [ line, 0 ] : EMPTY_NODE_OFFSET;\n}\n\n\nexport function textNodeLength(lines: Types, node: Node) {\n  const value = node.nodeValue || '';\n  if (value.trim() || !(lines.matches(node.previousSibling) || lines.matches(node.nextSibling))) {\n    return value.length;\n  }\n  return 0;\n}\n","import { isEqual, TextDocument, AttributeMap, Line, EditorRange, Delta, Op } from '@typewriter/document';\nimport { h, patch, VChild, VNode } from './vdom';\nimport Editor from '../Editor';\nimport { LineType } from '../typesetting/typeset';\nimport { applyDecorations } from '../modules/decorations';\n\nconst EMPTY_ARR = [];\nconst BR = h('br', {});\nconst nodeFormatType = new WeakMap();\nconst linesType = new WeakMap<AttributeMap, LineType>();\nconst linesMultiples = new WeakMap<Line, Line[]>();\nconst linesCombined = new WeakMap<Line[], CombinedData>();\nconst nodeRanges = new WeakMap<HTMLElement, WeakMap<Node, EditorRange>>();\n\nexport type CombinedEntry = Line | Line[];\nexport type Combined = CombinedEntry[];\ninterface CombinedData {\n  combined: Combined;\n  byKey:  Record<string, CombinedEntry>;\n}\ntype LineRanges = [EditorRange, EditorRange];\nexport interface HTMLLineElement extends HTMLElement {\n  key: string;\n}\n\nexport function getLineNodeStart(root: HTMLElement, node: Node) {\n  return nodeRanges.get(root)?.get(node)?.[0] as number;\n}\n\nexport function getLineNodeEnd(root: HTMLElement, node: Node) {\n  return nodeRanges.get(root)?.get(node)?.[1] as number;\n}\n\nexport function setLineNodesRanges(editor: Editor) {\n  const { root, doc } = editor;\n  const combined = combineLines(editor, doc.lines);\n  const ranges = new WeakMap<Node, EditorRange>();\n  for (let i = 0; i < root.children.length; i++) {\n    const child = root.children[i] as HTMLLineElement;\n    if (!child.key) continue;\n    const entry = combined.byKey[child.key];\n    if (!entry) continue;\n    if (Array.isArray(entry)) {\n      // set the range for the entire combined section\n      ranges.set(child, [ doc.getLineRange(entry[0])[0], doc.getLineRange(entry[entry.length - 1])[1] ]);\n\n      // set the ranges for each line inside\n      const lineElements = child.querySelectorAll(editor.typeset.lines.selector) as any as HTMLLineElement[];\n      for (let i = 0; i < lineElements.length; i++) {\n        const lineElement = lineElements[i];\n        const line = doc.getLineBy(lineElement.key);\n        if (!line) continue;\n        ranges.set(lineElement, doc.getLineRange(line));\n      }\n    } else {\n      ranges.set(child, doc.getLineRange(entry));\n    }\n  }\n  const lineElements = root.querySelectorAll(editor.typeset.lines.selector) as any as HTMLLineElement[];\n  for (let i = 0; i < lineElements.length; i++) {\n    const lineElement = lineElements[i];\n    if (ranges.has(lineElement) || !lineElement.key) continue;\n    const line = doc.getLineBy(lineElement.key);\n    ranges.set(lineElement, doc.getLineRange(line));\n  }\n  nodeRanges.set(root, ranges);\n}\n\n\nexport function render(editor: Editor, doc: TextDocument) {\n  const { root } = editor;\n  editor.dispatchEvent(new Event('rendering'));\n  patch(root, renderDoc(editor, doc)) as HTMLElement;\n  setLineNodesRanges(editor);\n  editor.dispatchEvent(new Event('render'));\n  editor.dispatchEvent(new Event('rendered'));\n}\n\n\nexport function renderChanges(editor: Editor, oldDoc: TextDocument, newDoc: TextDocument) {\n  const { root } = editor;\n  // Ranges of line indexes, not document indexes\n  const oldCombined = combineLines(editor, oldDoc.lines).combined;\n  const newCombined = combineLines(editor, newDoc.lines).combined;\n  const [ oldRange, newRange ] = getChangedRanges(oldCombined, newCombined);\n\n  // If the changes include added or deleted lines, expand ranges by 1 on each side to ensure the vdom can rerender\n  if (!isEqual(oldRange, newRange)) {\n    oldRange[0] = Math.max(0, oldRange[0] - 1);\n    newRange[0] = Math.max(0, newRange[0] - 1);\n    oldRange[1] = Math.min(oldCombined.length, oldRange[1] + 1);\n    newRange[1] = Math.min(newCombined.length, newRange[1] + 1);\n    if (root.childNodes.length !== oldCombined.length) {\n      // The DOM has changed since we last rendered, adjust the oldRange accordingly to get the correct slice\n      oldRange[1] += root.childNodes.length - oldCombined.length;\n    }\n  }\n\n  const oldSlice = Array.from(root.childNodes).slice(oldRange[0], oldRange[1]);\n  const newSlice = newCombined.slice(newRange[0], newRange[1]);\n  if (!oldSlice.length && !newSlice.length) return render(editor, newDoc);\n  editor.dispatchEvent(new Event('rendering'));\n  patch(root, renderCombined(editor, newSlice), oldSlice) as HTMLElement;\n  setLineNodesRanges(editor);\n  editor.dispatchEvent(new Event('render'));\n  editor.dispatchEvent(new Event('rendered'));\n}\n\nexport function renderDoc(editor: Editor, doc: TextDocument, forHTML?: boolean) {\n  return renderCombined(editor, combineLines(editor, doc.lines).combined, forHTML);\n}\n\nexport function renderCombined(editor: Editor, combined: Combined, forHTML?: boolean) {\n  return combined.map(line => renderLine(editor, line, forHTML)).filter(Boolean) as VNode[];\n}\n\nexport function renderLine(editor: Editor, line: CombinedEntry, forHTML?: boolean) {\n  return Array.isArray(line) ? renderMultiLine(editor, line, forHTML) : renderSingleLine(editor, line, forHTML);\n}\n\nexport function renderSingleLine(editor: Editor, line: Line, forHTML?: boolean) {\n  const type = getLineType(editor, line);\n  if (!type.render) throw new Error('No render method defined for line');\n  const node = type.render(line.attributes as AttributeMap, renderInline(editor, line.content), editor, forHTML);\n  applyDecorations(node, line.attributes);\n  node.key = line.id;\n  return node;\n}\n\nexport function renderMultiLine(editor: Editor, lines: Line[], forHTML?: boolean) {\n  const type = getLineType(editor, lines[0]);\n  if (!type.renderMultiple) throw new Error('No render method defined for line');\n  const node = type.renderMultiple(lines.map(line => [ line.attributes, renderInline(editor, line.content), line.id ]), editor, forHTML);\n  node.key = lines[0].id;\n  return node;\n}\n\n// Join multi-lines into arrays. Memoize the results.\nexport function combineLines(editor: Editor, lines: Line[]): CombinedData {\n  const cache = linesCombined.get(lines);\n  if (cache) return cache;\n\n  const combined: Combined = [];\n  const byKey: Record<string, CombinedEntry> = {};\n  let collect: Line[] = [];\n\n  lines.forEach((line, i) => {\n    const type = getLineType(editor, line);\n\n    if (type.shouldCombine) {\n      collect.push(line);\n      const next = lines[i + 1];\n      if (!next || getLineType(editor, next) !== type || !type.shouldCombine(line.attributes, next.attributes)) {\n        // By keeping the last array reference we can optimize updates\n        const last = linesMultiples.get(collect[0]);\n        if (last && last.length === collect.length && collect.every((v, i) => last[i] === v)) {\n          collect = last;\n        } else {\n          linesMultiples.set(collect[0], collect);\n        }\n        combined.push(collect);\n        byKey[collect[0].id] = collect;\n        collect = [];\n      }\n    } else if (type.render) {\n      combined.push(line);\n      byKey[line.id] = line;\n    }\n  });\n\n  const data = { combined, byKey };\n  linesCombined.set(lines, data);\n  return data;\n}\n\n// Most changes will occur to adjacent lines, so the simplistic approach\nexport function getChangedRanges(oldC: Combined, newC: Combined): LineRanges {\n  const oldLength = oldC.length;\n  const newLength = newC.length;\n  const minLength = Math.min(oldLength, newLength);\n  let oldStart = 0, oldEnd = 0, newStart = 0, newEnd = 0;\n  for (let i = 0; i < minLength; i++) {\n    if (!isSame(oldC[i], newC[i])) {\n      oldStart = newStart = i;\n      break;\n    }\n  }\n  for (let i = 0; i < minLength; i++) {\n    if (!isSame(oldC[oldLength - i - 1], newC[newLength - i - 1])) {\n      oldEnd = oldLength - i;\n      newEnd = newLength - i;\n      break;\n    }\n  }\n  return [[ oldStart, oldEnd ], [ newStart, newEnd ]];\n}\n\n\nexport function renderInline(editor: Editor, delta: Delta, forHTML?: boolean) {\n  const { formats, embeds } = editor.typeset;\n  let inlineChildren: VChild[] = [];\n  let trailingBreak = true;\n\n  delta.ops.forEach((op, i, array) => {\n    let children: VChild[] = [];\n    if (typeof op.insert === 'string') {\n      const prev = array[i - 1];\n      const next = array[i + 1];\n      let str: string = op.insert.replace(/  /g, '\\xA0 ').replace(/  /g, ' \\xA0');\n      if (!prev || typeof prev.insert === 'object') str = str.replace(/^ /, '\\xA0');\n      if (!next || typeof next.insert === 'object' || startsWithSpace(next)) str = str.replace(/ $/, '\\xA0');\n      trailingBreak = false;\n      children.push(str);\n    } else if (op.insert) {\n      const embed = embeds.findByAttributes(op.insert);\n      if (embed?.render) {\n        children.push(embed.render(op.insert, EMPTY_ARR, editor, forHTML));\n        if (embed.name === 'br') trailingBreak = true;\n        else if (!embed.noFill) trailingBreak = false;\n      }\n    }\n\n    if (op.attributes) {\n      // Sort them by the order found in formats\n      Object.keys(op.attributes).sort((a, b) => formats.priority(b) - formats.priority(a)).forEach(name => {\n        const type = formats.get(name);\n        if (type?.render) {\n          const node = type.render(op.attributes as AttributeMap, children, editor, forHTML);\n          if (node) {\n            nodeFormatType.set(node, type); // Store for merging\n            children = [ node ];\n          }\n        }\n      });\n    }\n\n    inlineChildren.push.apply(inlineChildren, children);\n  });\n\n  // Merge marks to optimize\n  inlineChildren = mergeChildren(inlineChildren);\n  if (trailingBreak) inlineChildren.push(BR);\n\n  return inlineChildren;\n}\n\n\nfunction isSame(oldEntry: CombinedEntry, newEntry: CombinedEntry): boolean {\n  if (oldEntry === newEntry) return true;\n  return Array.isArray(oldEntry)\n    && Array.isArray(newEntry)\n    && oldEntry.length === newEntry.length\n    && oldEntry.every((b, i) => b === newEntry[i]);\n}\n\n\nfunction getLineType(editor: Editor, line: Line): LineType {\n  let type = linesType.get(line.attributes);\n  if (!type) {\n    type = editor.typeset.lines.findByAttributes(line.attributes, true);\n    linesType.set(line.attributes, type);\n  }\n  return type;\n}\n\n\n\n// Joins adjacent mark nodes\nfunction mergeChildren(oldChildren: VChild[]) {\n  const children: VChild[] = [];\n  oldChildren.forEach((next, i) => {\n    const index = children.length - 1;\n    const prev = children[index];\n\n    if (prev && typeof prev !== 'string' && typeof next !== 'string' && nodeFormatType.has(prev) &&\n      nodeFormatType.get(prev) === nodeFormatType.get(next) && isEqual(prev.props, next.props))\n    {\n      prev.children = prev.children.concat(next.children);\n    } else if (prev && typeof prev === 'string' && typeof next === 'string') {\n      children[index] += next; // combine adjacent text nodes\n    } else {\n      children.push(next);\n      if (prev && typeof prev !== 'string' && prev.children) {\n        prev.children = mergeChildren(prev.children);\n      }\n    }\n  });\n  if (children.length) {\n    const last = children[children.length - 1];\n    if (last && typeof last !== 'string' && last.children) {\n      last.children = mergeChildren(last.children);\n    }\n  }\n  return children;\n}\n\nfunction startsWithSpace(op: Op) {\n  return typeof op.insert === 'string' && op.insert[0] === ' ';\n}\n","\nimport { EditorRange } from '@typewriter/document';\nimport Editor from '../Editor';\nimport { getIndexFromNodeAndOffset, getNodesForRange } from './position';\n\n\n/**\n * Get the selection range from the current browser selection\n */\nexport function getSelection(editor: Editor): EditorRange | null {\n  const { root } = editor;\n  const current = editor.doc.selection;\n  if (!root.ownerDocument) return null;\n  const selection = root.ownerDocument.getSelection();\n  const { lines } = editor.typeset;\n\n  if (selection == null || selection.anchorNode == null || selection.focusNode == null || !root.contains(selection.anchorNode)) {\n    return null;\n  } else {\n    const anchorIndex = getIndexFromNodeAndOffset(editor, selection.anchorNode, selection.anchorOffset, current && current[0]);\n    const isCollapsed = selection.anchorNode === selection.focusNode && selection.anchorOffset === selection.focusOffset;\n    const isFrozen = lines.findByAttributes(editor.doc.getLineAt(anchorIndex)?.attributes, true).frozen;\n    // selection.isCollapsed causes a re-layout on Chrome, manual detection does not.\n    let focusIndex = isCollapsed\n      ? anchorIndex\n      : getIndexFromNodeAndOffset(editor, selection.focusNode, selection.focusOffset, !isFrozen && current ? current[1] : null);\n\n    return [ anchorIndex, focusIndex ];\n  }\n}\n\n/**\n * Set the current browser selection to the given selection range\n */\nexport function setSelection(editor: Editor, range: EditorRange | null) {\n  const { root } = editor;\n  if (!root.ownerDocument) return;\n  const selection = root.ownerDocument.getSelection();\n  if (!selection) return;\n  const hasFocus = selection.anchorNode && root.contains(selection.anchorNode) && document.activeElement !== document.body;\n\n  if (range == null) {\n    if (hasFocus) {\n      selection.removeAllRanges();\n      if (root.classList.contains('focus')) root.classList.remove('focus');\n    }\n  } else {\n    const [ anchorNode, anchorOffset, focusNode, focusOffset ] = getNodesForRange(editor, range);\n    const type = range[0] === range[1] ? 'Caret' : 'Range';\n    if (anchorNode && focusNode) {\n      if (selection.anchorNode !== anchorNode || selection.anchorOffset !== anchorOffset ||\n          selection.focusNode !== focusNode || selection.focusOffset !== focusOffset || selection.type !== type)\n      {\n        selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n      }\n    }\n    if (!hasFocus) root.focus();\n    if (!root.classList.contains('focus')) root.classList.add('focus');\n  }\n  root.dispatchEvent(new Event('select', { bubbles: true }));\n}\n","// Based off of https://github.com/jorgebucaran/superfine/ MIT licensed\nexport interface Props {\n  [key: string]: any\n}\n\nexport type VChild = VNode | string\n\nexport interface VNode {\n  type: string\n  props: Props\n  children: VChild[]\n  key: any\n}\n\n// Expose to allow debugging of keys on line elements\nexport const options = {\n  renderKeys: false,\n};\n\ntype Node = Element | Text;\n\n\nconst EMPTY_ARR = []\nconst SVG_NS = 'http://www.w3.org/2000/svg'\nconst KEY_ATTR = 'data-key';\nconst domProps = new Set([ 'value', 'selected', 'checked', 'contentEditable' ])\n\nconst getKey = (vdom: VChild | Node) => (vdom == null ? vdom : (vdom as any).key)\nconst setKey = (dom: any, key?: string) => {\n  if (key && key !== dom.key) {\n    dom.key = key\n    options.renderKeys && dom.setAttribute(KEY_ATTR, key);\n  } if (!key && dom.key) {\n    delete dom.key\n    options.renderKeys && dom.removeAttribute(KEY_ATTR);\n  }\n}\n\nconst listener = (event: Event) => {\n  (event.currentTarget as any).events[event.type](event)\n}\n\nconst patchProp = (dom: Element, key: string, oldVal: any, newVal: any, isSvg?: boolean) => {\n  if (key === 'key') {\n  } else if (key[0] === 'o' && key[1] === 'n') {\n    if (!(((dom as any).events || ((dom as any).events = {}))[(key = key.slice(2))] = newVal)) {\n      dom.removeEventListener(key, listener)\n    } else if (!oldVal) {\n      dom.addEventListener(key, listener)\n    }\n  } else if (newVal == null) {\n    dom.removeAttribute(key)\n  } else if (!isSvg && key !== 'list' && key !== 'form' && key in dom) {\n    dom[key] = newVal == null ? '' : newVal\n  } else {\n    dom.setAttribute(key, newVal)\n  }\n}\n\nconst createNode = (vdom: VChild, isSvg?: boolean) => {\n  if (typeof vdom === 'string') {\n    return document.createTextNode(vdom);\n  }\n  var props = (vdom as VNode).props;\n  var dom =\n    (isSvg = (isSvg || vdom.type === 'svg'))\n      ? document.createElementNS(SVG_NS, vdom.type, { is: props.is })\n      : document.createElement(vdom.type, { is: props.is })\n\n  for (var k in props) patchProp(dom as Element, k, null, props[k], isSvg)\n  setKey(dom, getKey(vdom))\n\n  vdom.children.forEach(kid => dom.appendChild(createNode(vdomify(kid), isSvg)))\n\n  return dom\n}\n\nconst getDomProps = (dom: Element, isSvg?: boolean): Props => {\n  const props: Props = {}\n  for (let i = 0; i < dom.attributes.length; i++) {\n    const { name, value } = dom.attributes[i]\n    if (name in dom && name !== 'list' && !isSvg) {\n      props[name] = dom[name]\n    } else if (!options.renderKeys || name !== KEY_ATTR) {\n      props[name] = value === '' ? true : value\n    }\n  }\n  return props\n}\n\nconst patchDom = (parent: Node, dom: Node, oldDom: Node | null, newVdom: VChild, isSvg?: boolean) => {\n  if (typeof newVdom === 'string') {\n    if (oldDom != null && oldDom.nodeType === Node.TEXT_NODE) {\n      if (oldDom.nodeValue !== newVdom) dom.nodeValue = newVdom\n    } else {\n      dom = parent.insertBefore(createNode(newVdom, isSvg), dom)\n      if (oldDom != null) {\n        parent.removeChild(oldDom);\n      }\n    }\n  } else if (oldDom == null || oldDom.nodeName.toLowerCase() !== (newVdom as VNode).type) {\n    dom = parent.insertBefore(\n      createNode(vdomify(newVdom), isSvg),\n      dom\n    )\n    if (oldDom != null) {\n      parent.removeChild(oldDom);\n    }\n  } else {\n    var oldProps = getDomProps(oldDom as Element, isSvg),\n      newProps = newVdom.props\n\n    isSvg = isSvg || newVdom.type === 'svg'\n\n    for (var i in { ...oldProps, ...newProps }) {\n      if (\n        (domProps.has(i)\n          ? dom[i]\n          : oldProps[i]) !== newProps[i]\n      ) {\n        patchProp(dom as Element, i, oldProps[i], newProps[i], isSvg)\n      }\n    }\n    setKey(dom, newVdom.key)\n\n    patchChildren(dom, newVdom.children, isSvg)\n  }\n\n  return dom\n}\n\nconst patchChildren = (dom: Node, newVKids: VChild[], isSvg?: boolean, oldKids: Node[] = Array.from(dom.childNodes) as Node[]) => {\n  var tmpKid: Node,\n    oldKid: Node,\n    oldKey: any,\n    newKey: any,\n    oldHead = 0,\n    newHead = 0,\n    oldTail = oldKids.length - 1,\n    newTail = newVKids.length - 1\n\n  // Patch children with the same key from the beginning until they diverge\n  while (newHead <= newTail && oldHead <= oldTail) {\n    if (\n      (oldKey = getKey(oldKids[oldHead])) == null ||\n      oldKey !== getKey(newVKids[newHead])\n    ) {\n      break\n    }\n\n    patchDom(\n      dom,\n      oldKids[oldHead],\n      oldKids[oldHead++],\n      (newVKids[newHead] = vdomify(newVKids[newHead++])),\n      isSvg\n    )\n  }\n\n  // Patch children with the same key backwards from the end until they diverge\n  while (newHead <= newTail && oldHead <= oldTail) {\n    if (\n      (oldKey = getKey(oldKids[oldTail])) == null ||\n      oldKey !== getKey(newVKids[newTail])\n    ) {\n      break\n    }\n\n    // Update the reference for insertBefore references\n    oldKids[oldTail] = patchDom(\n      dom,\n      oldKids[oldTail],\n      oldKids[oldTail--],\n      (newVKids[newTail] = vdomify(newVKids[newTail--])),\n      isSvg\n    )\n  }\n\n  if (oldHead > oldTail) {\n    // All old matched, so new nodes were inserted\n    const insertBefore = oldKids[oldHead] || (oldKids[oldHead - 1] && oldKids[oldHead - 1].nextSibling || null);\n    while (newHead <= newTail) {\n      dom.insertBefore(\n        createNode((newVKids[newHead] = vdomify(newVKids[newHead++])), isSvg),\n        insertBefore\n      )\n    }\n  } else if (newHead > newTail) {\n    // All new matched, so extra old nodes needing to be removed\n    while (oldHead <= oldTail) {\n      dom.removeChild(oldKids[oldHead++]);\n    }\n  } else {\n    // 1 or more from old and new need to be removed/added\n    // cache old keys to their dom\n    const oldKeyed = new Map<any, Node>();\n    const newKeyed = new Set<any>()\n    for (let i = oldHead; i <= oldTail; i++) {\n      if ((oldKey = getKey(oldKids[i])) != null) {\n        oldKeyed.set(oldKey, oldKids[i])\n      }\n    }\n\n    // Go through the rest of the new to add/update them\n    while (newHead <= newTail) {\n      oldKey = getKey((oldKid = oldKids[oldHead]))\n      newKey = getKey((newVKids[newHead] = vdomify(newVKids[newHead])))\n\n      // If the old key was placed somewhere else already, or the new key is after this old one, remove it\n      if (\n        newKeyed.has(oldKey) ||\n        (newKey != null && newKey === getKey(oldKids[oldHead + 1]))\n      ) {\n        if (oldKey == null) {\n          dom.removeChild(oldKid)\n        }\n        oldHead++\n        continue\n      }\n\n      if (newKey == null) {\n        if (oldKey == null) {\n          // Both keys are null, just patch it\n          patchDom(\n            dom,\n            oldKid,\n            oldKid,\n            newVKids[newHead],\n            isSvg\n          )\n          newHead++\n        }\n        // otherwise move on, we'll remove this old one below when we iterate through oldKeyed\n        oldHead++\n      } else {\n        if (oldKey === newKey) {\n          // They match, just patch them (incr newHead below)\n          patchDom(dom, oldKid, oldKid, newVKids[newHead], isSvg)\n          newKeyed.add(newKey)\n          oldHead++\n        } else {\n          if ((tmpKid = oldKeyed.get(newKey) as Node) != null) {\n            // If the matching old node is in the dom already, pull it into this location and patch it\n            patchDom(\n              dom,\n              dom.insertBefore(tmpKid, oldKid),\n              tmpKid,\n              newVKids[newHead],\n              isSvg\n            )\n            newKeyed.add(newKey)\n          } else {\n            // This is a new item and there is no old or the old no longer belongs, patch it in, leaving oldKid\n            patchDom(\n              dom,\n              oldKid,\n              null,\n              newVKids[newHead],\n              isSvg\n            )\n          }\n        }\n        newHead++\n      }\n    }\n\n    while (oldHead <= oldTail) {\n      if (getKey((oldKid = oldKids[oldHead++])) == null) {\n        dom.removeChild(oldKid)\n      }\n    }\n\n    for (const [ key, node ] of oldKeyed) {\n      if (!newKeyed.has(key)) {\n        dom.removeChild(node)\n      }\n    }\n  }\n\n  return dom\n}\n\nconst vdomify = (vdom: any): VChild =>\n  vdom !== true && vdom !== false && vdom ? vdom : ''\n\n\nconst createVdom = (type: string, props: Props, children: VChild[], key?: any): VNode => ({\n  type,\n  props,\n  children,\n  key,\n})\n\nexport const recycleNode = (dom: Node) =>\n  dom.nodeType === Node.TEXT_NODE\n    ? dom.nodeValue as string\n    : createVdom(\n        dom.nodeName.toLowerCase(),\n        getDomProps(dom as Element),\n        EMPTY_ARR.map.call(dom.childNodes, recycleNode) as VNode[],\n        getKey(dom),\n      )\n\nexport const h = (type: string | Function, props?: Props | null, ch?: VChild | VChild[]) =>\n  typeof type === 'function'\n    ? type(props || {}, ch)\n    : createVdom(\n        type,\n        props || {},\n        Array.isArray(ch) ? ch : ch == null ? [] : [ch],\n        props?.key\n  )\n\n// Helper for Typescript JSX which translates JSX into React.createElement() calls.\n// Add `import { React } from 'typewriter-editor';` at the top of any .tsx page to use JSX.\nexport const React = { createElement: h };\n\nexport const patch = (dom: Node, vdom: VNode | VNode[], oldKids?: ChildNode[]) => {\n  if (Array.isArray(vdom)) {\n    dom = patchChildren(dom, vdom, dom instanceof window.SVGElement, oldKids as Node[]);\n  } else {\n    dom = patchDom(dom.parentNode as Node, dom, dom, vdom)\n  }\n  return dom\n}\n","const SHOW = NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT;\n\nexport function createTreeWalker(root: Node, filter?: (node: Node) => boolean | number) {\n  return (root.ownerDocument || document).createTreeWalker(root, SHOW, {\n    acceptNode(node) {\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue === '') {\n        return NodeFilter.FILTER_REJECT;\n      } else if (filter) {\n        const result = filter(node);\n        if (!result) return NodeFilter.FILTER_REJECT;\n        if (result === true) return NodeFilter.FILTER_ACCEPT;\n        return result;\n      } else {\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n  });\n}\n","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { stylesheet } = info;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            info.rules = {};\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape_attribute_value(value.toString())}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.48.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        throw new Error(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n","import { derived, readable, writable, Readable, get } from 'svelte/store';\nimport { AttributeMap, EditorRange, TextDocument, isEqual } from '@typewriter/document';\nimport Editor from './Editor';\n\nconst EMPTY_NOPTIFIER = () => {};\nconst EMPTY_ACTIVE = readable({} as AttributeMap, EMPTY_NOPTIFIER);\nconst EMPTY_DOC = readable(new TextDocument(), EMPTY_NOPTIFIER);\nconst EMPTY_SELECTION = readable(null, EMPTY_NOPTIFIER);\nconst EMPTY_ROOT = readable(undefined, EMPTY_NOPTIFIER);\n\n\nexport interface EditorStores {\n  active: Readable<AttributeMap>;\n  doc: Readable<TextDocument>;\n  selection: Readable<EditorRange | null>;\n  root: Readable<HTMLElement | undefined>;\n  focus: Readable<boolean>;\n  updateEditor(editor: Editor): void;\n}\n\n\nexport function editorStores(editor: Editor): EditorStores {\n  const active = proxy(activeStore(editor));\n  const doc = proxy(docStore(editor));\n  const selection = proxy(selectionStore(editor));\n  const root = proxy(rootStore(editor));\n  const focus = focusStore(selection);\n\n  function updateEditor(value: Editor) {\n    if (value === editor) return;\n    editor = value;\n    active.set(activeStore(editor));\n    doc.set(docStore(editor));\n    selection.set(selectionStore(editor));\n    root.set(rootStore(editor));\n  }\n\n  return {\n    active,\n    doc,\n    selection,\n    root,\n    focus,\n    updateEditor,\n  };\n}\n\n\nexport function activeStore(editor?: Editor) {\n  if (!editor) return EMPTY_ACTIVE;\n  let active = editor.getActive();\n\n  return readable<AttributeMap>(active, set => {\n    const update = () => {\n      const newActive = editor.getActive();\n      if (!isEqual(active, newActive)) set(active = newActive);\n    }\n    editor.on('changed', update);\n    editor.on('format', update);\n    return () => {\n      editor.off('changed', update);\n      editor.off('format', update);\n    }\n  });\n}\n\n\nexport function docStore(editor: Editor) {\n  if (!editor) return EMPTY_DOC;\n  return readable<TextDocument>(editor.doc, set => {\n    const update = () => set(editor.doc)\n    update();\n    editor.on('changed', update);\n    return () => editor.off('changed', update);\n  });\n}\n\n\nexport function selectionStore(editor: Editor) {\n  if (!editor) return EMPTY_SELECTION;\n  return readable<EditorRange | null>(editor.doc.selection, set => {\n    const update = () => set(editor.doc.selection)\n    update();\n    editor.on('changed', update);\n    return () => editor.off('changed', update);\n  });\n}\n\n\nexport function focusStore(selection: Readable<EditorRange | null>) {\n  return derived(selection, selection => !!selection);\n}\n\n\nexport function rootStore(editor: Editor) {\n  if (!editor) return EMPTY_ROOT;\n  return readable<HTMLElement | undefined>(editor._root, set => {\n    const update = () => set(editor._root)\n    update();\n    editor.on('root', update);\n    return () => editor.off('root', update);\n  });\n}\n\n\n// Can be create in a component on init and set to another store async, allowing for $mystore use\nexport function proxy<T>(defaultValueOrStore: T | Readable<T>) {\n  const defaultValue = 'subscribe' in defaultValueOrStore ? get(defaultValueOrStore) : defaultValueOrStore;\n  const { set: write, subscribe } = writable<T>(defaultValue);\n  let unsub: Function;\n\n  if ('subscribe' in defaultValueOrStore) {\n    set(defaultValueOrStore);\n  }\n\n  function set(store: Readable<T>) {\n    if (unsub) unsub();\n    if (store) unsub = store.subscribe(value => write(value));\n  }\n\n  return {\n    set,\n    subscribe\n  };\n}\n","import { AttributeMap, Delta, normalizeRange } from '@typewriter/document';\nimport { VNode, h, Props, VChild } from '../rendering/vdom';\nimport { line } from './typeset';\nimport { applyDecorations } from '../modules/decorations';\n\n\nexport const paragraph = line({\n  name: 'paragraph',\n  selector: 'p',\n  commands: editor => () => editor.formatLine({}),\n  shortcuts: 'Mod+0',\n  render: (attributes, children) => h('p', null, children)\n});\n\nexport const header = line({\n  name: 'header',\n  selector: 'h1, h2, h3, h4, h5, h6',\n  defaultFollows: true,\n  commands: editor => ({\n    header: (header: number) => editor.toggleLineFormat({ header }),\n    header1: () => editor.toggleLineFormat({ header: 1 }),\n    header2: () => editor.toggleLineFormat({ header: 2 }),\n    header3: () => editor.toggleLineFormat({ header: 3 }),\n    header4: () => editor.toggleLineFormat({ header: 4 }),\n    header5: () => editor.toggleLineFormat({ header: 5 }),\n    header6: () => editor.toggleLineFormat({ header: 6 }),\n  }),\n  shortcuts: {\n    'Mod+1': 'header1',\n    'Mod+2': 'header2',\n    'Mod+3': 'header3',\n    'Mod+4': 'header4',\n    'Mod+5': 'header5',\n    'Mod+6': 'header6',\n  },\n  fromDom: (node: Node) => ({ header: parseInt(node.nodeName.replace('H', '')) }),\n  render: (attributes, children) => h(`h${attributes.header}` as any, null, children),\n});\n\nexport const list = line({\n  name: 'list',\n  selector: 'ul > li, ol > li',\n  indentable: true,\n  commands: editor => ({\n    bulletList: () => editor.toggleLineFormat({ list: 'bullet' }),\n    orderedList: () => editor.toggleLineFormat({ list: 'ordered' }),\n    checkList: () => editor.toggleLineFormat({ list: 'check' }),\n    indent: () => editor.indent(),\n    outdent: () => editor.outdent(),\n    toggleCheck: (id: string) => {\n      const line = typeof id === 'string'\n        ? editor.doc.getLineBy(id)\n        : editor.doc.selection\n        ? editor.doc.getLineAt(editor.doc.selection[0])\n        : null;\n      if (!line) return false;\n      const [ at ] = editor.doc.getLineRange(line);\n      const format = { list: 'check' } as AttributeMap;\n      if (!line.attributes.checked) format.checked = true;\n      editor.formatLine(format, at)\n    },\n  }),\n  shortcuts: {\n    'Mod+Space': 'toggleCheck',\n  },\n  fromDom(node: HTMLElement) {\n    let indent = -1, parent = node.parentNode;\n    const list = node.hasAttribute('data-checked') ? 'check' : parent && parent.nodeName === 'OL' ? 'ordered' : 'bullet';\n    while (parent) {\n      if (/^UL|OL$/.test(parent.nodeName)) indent++;\n      else if (parent.nodeName !== 'LI') break;\n      parent = parent.parentNode;\n    }\n    if (!indent && node.className.startsWith('ql-indent-')) {\n      // Support pasting from quilljs content\n      indent = parseInt(node.className.replace('ql-indent-', ''));\n    }\n    const attr: { list: string, checked?: boolean, indent?: number } = { list };\n    if (indent) attr.indent = indent;\n    if (node.getAttribute('data-checked') === 'true') attr.checked = true;\n    return attr;\n  },\n  nextLineAttributes(attributes) {\n    const { start, ...rest } = attributes;\n    return rest;\n  },\n  shouldCombine: (prev, next) => prev.list === next.list || next.indent,\n  renderMultiple: (lists, editor, forHTML) => {\n    const topLevelChildren: VNode[] = [];\n    const levels: VNode[] = [];\n    // e.g. levels = [ul, ul]\n\n    lists.forEach(([ attributes, children, id ]) => {\n      const type = attributes.list === 'ordered' ? 'ol' : 'ul';\n      const index = attributes.indent as number || 0;\n      let props: Props = { key: id };\n      if (attributes.list === 'check') {\n        function toggle(event: any) {\n          if (!editor.enabled) return;\n          event.preventDefault();\n          editor.commands.toggleCheck(id);\n        }\n        const check = h('button', { class: 'check-list-check', onmousedown: toggle, ontouchstart: toggle, });\n        if (children.length === 1 && (children[0] as VNode).type === 'br') children.push(check);\n        else children.unshift(check);\n        props = {\n          ...props,\n          class: 'check-list-item',\n          ['data-checked']: '' + (attributes.checked || false),\n        };\n      }\n      const item = applyDecorations(h('li', props, children), attributes);\n\n      while (index >= levels.length) {\n        const newLevel = h(type, { start: attributes.start, type: attributes.type, key: `${id}-outer` });\n        const childrenArray = levels.length ? levels[levels.length - 1].children : topLevelChildren;\n        const lastChild = childrenArray[childrenArray.length - 1];\n        if (typeof lastChild === 'object' && lastChild.type === 'li') {\n          if (forHTML) {\n            // Correct HTML\n            lastChild.children.push(newLevel);\n          } else {\n            // Technically incorrect HTML needed to fix selection bug: when clicking to the right of a list item with a\n            // sub-item, the selection goes to the start of the line instead of the end\n            childrenArray.push(newLevel);\n          }\n        } else {\n          childrenArray.push(newLevel);\n        }\n        levels.push(newLevel);\n      }\n\n      if (!compareLists(levels[index], type, attributes)) {\n        const newLevel = h(type, { start: attributes.start, type: attributes.type });\n        const childrenArray = index ? levels[index - 1].children : topLevelChildren;\n        childrenArray.push(newLevel);\n        levels[index] = newLevel;\n      }\n\n      levels[index].children.push(item);\n\n      levels.length = index + 1;\n    });\n\n    function compareLists(list: VNode, type: string, attributes: AttributeMap) {\n      return list.type === type\n        && (list.props.start === attributes.start\n            || (list.props.start && !attributes.start))\n        && list.props.type === attributes.type;\n    }\n\n    return topLevelChildren[0];\n  }\n});\n\nexport const blockquote = line({\n  name: 'blockquote',\n  selector: 'blockquote p',\n  commands: editor => (blockquote: string | true | any = true) => {\n    if (typeof blockquote !== 'string') blockquote = true;\n    editor.toggleLineFormat({ blockquote })\n  },\n  fromDom(node: HTMLParagraphElement) {\n    const { className } = (node.parentNode as HTMLElement);\n    const match = className.match(/quote-(\\S+)/);\n    const blockquote = match && match[1] !== 'true' && match[1] || true;\n    return { blockquote };\n  },\n  shouldCombine: (prev, next) => prev.blockquote === next.blockquote,\n  renderMultiple: quotes => {\n    const type = quotes[0][0].blockquote;\n    const props = typeof type === 'string' ? { className: `quote-${type}`} : null;\n    const children = quotes.map(([ attributes, children, id ]) => h('p', { key: id }, children));\n    return h('blockquote', props, children);\n  }\n});\n\nexport const codeblock = line({\n  name: 'code-block',\n  selector: 'pre code',\n  contained: true,\n  commands: editor => () => editor.toggleLineFormat({ ['code-block']: true }),\n  renderMultiple: lines => {\n    const children: VChild[] = [];\n    lines.forEach(([ attributes, inlineChildren, id ]) => {\n      if (inlineChildren.length && ((inlineChildren[inlineChildren.length - 1] as VNode).type === 'br')) {\n        inlineChildren.pop();\n      }\n      children.push(h('code', { key: id }, inlineChildren));\n      children.push('\\n');\n    });\n    return h('pre', { spellcheck: false }, children);\n  }\n});\n\nexport const hr = line({\n  name: 'hr',\n  selector: 'hr',\n  frozen: true,\n  commands: editor => () => {\n    const { doc } = editor;\n    const { selection } = doc;\n    if (!selection) return;\n    const range = normalizeRange(selection);\n    const change = editor.change.delete(range);\n    if (range[0] === range[1] && doc.getLineAt(range[0]).length === 1) {\n      change\n        .insert(range[0], '\\n', { ...doc.getLineFormat(range[0]) })\n        .formatLine(range[0], { hr: true });\n    } else {\n      const delta = new Delta()\n        .insert('\\n', doc.getLineAt(range[0]).attributes)\n        .insert('\\n', { hr: true });\n      change.insertContent(range[0], delta);\n      change.select(range[0] + 2);\n    }\n    editor.update(change);\n  },\n  render: () => h('hr'),\n});\n","import { h } from '../rendering/vdom';\nimport { format } from './typeset';\n\n\nexport const bold = format({\n  name: 'bold',\n  selector: 'strong, b',\n  styleSelector: '[style*=\"font-weight:bold\"], [style*=\"font-weight: bold\"]',\n  commands: editor => () => editor.toggleTextFormat({ bold: true }),\n  shortcuts: 'Mod+B',\n  render: (attributes, children) => h('strong', null, children),\n});\n\nexport const italic = format({\n  name: 'italic',\n  selector: 'em, i',\n  styleSelector: '[style*=\"font-style:italic\"], [style*=\"font-style: italic\"]',\n  commands: editor => () => editor.toggleTextFormat({ italic: true }),\n  shortcuts: 'Mod+I',\n  render: (attributes, children) => h('em', null, children),\n});\n\nexport const code = format({\n  name: 'code',\n  selector: 'code',\n  commands: editor => () => editor.toggleTextFormat({ code: true }),\n  render: (attributes, children) => h('code', null, children),\n});\n\nexport const link = format({\n  name: 'link',\n  selector: 'a[href]',\n  greedy: false,\n  // If the link is a string, it is an actual address. Otherwise it is either undefined (empty) or being called from the\n  // testing code (which passes a pointer to the dom object, hence the conversion to a boolean which works with the toggleTextFormat)\n  commands: editor => (link: string) => editor.toggleTextFormat({ link: typeof link === 'string' ? link : !!link }),\n  fromDom: (node: HTMLAnchorElement) => node.href,\n  render: (attributes, children) => h('a', { href: attributes.link, target: '_blank' }, children),\n});\n","import { h } from '../rendering/vdom';\nimport { embed } from './typeset';\nimport { AttributeMap } from '@typewriter/document';\n\n\nexport const image = embed({\n  name: 'image',\n  selector: 'img',\n  commands: editor => (image: string, props?: object) => editor.insert({ image, ...props }),\n  fromDom: (node: HTMLImageElement) => {\n    const image = {};\n    ['src', 'alt', 'width', 'height'].forEach(name => {\n      if (!node.hasAttribute(name)) return;\n      const value = node.getAttribute(name);\n      if (name === 'src') name = 'image';\n      image[name] = value;\n    });\n    return image;\n  },\n  render: (embed: AttributeMap) => {\n    const { image, ...props } = embed;\n    props.src = image;\n    return h('img', props);\n  },\n});\n\n\nexport const br = embed({\n  name: 'br',\n  selector: 'br',\n  commands: editor => () => editor.insert({ br: true }),\n  render: () => h('br'),\n});\n","import { TypesetTypes } from './typeset';\nimport './lines';\nimport './formats';\nimport './embeds';\n\nexport const defaultTypes: TypesetTypes = {\n  lines: [ 'paragraph', 'header', 'list', 'blockquote', 'code-block', 'hr', ],\n  formats: [ 'link', 'bold', 'italic', 'code', ],\n  embeds: [ 'image', 'br', ],\n};\n","import { AttributeMap } from '@typewriter/document';\nimport { VChild, VNode } from '../rendering/vdom';\nimport Editor, { Shortcuts } from '../Editor';\nconst EMPTY_ARR = [];\n\nconst lineTypes: Record<string, LineType> = {};\nconst formatTypes: Record<string, FormatType> = {};\nconst embedTypes: Record<string, BasicType> = {};\nconst shouldCombine: ShouldCombine = (prev, next) => true;\n\n\nexport class Typeset {\n  lines: Types<LineType>;\n  formats: Types<FormatType>;\n  embeds: Types<EmbedType>;\n\n  static line = line;\n  static format = format;\n  static embed = embed;\n\n  constructor(types: TypesetTypes) {\n    const lines = types.lines?.map(entry => typeof entry === 'string' ? lineTypes[entry] : entry).filter(Boolean);\n    const formats = types.formats?.map(entry => typeof entry === 'string' ? formatTypes[entry] : entry).filter(Boolean);\n    const embeds = types.embeds?.map(entry => typeof entry === 'string' ? embedTypes[entry] : entry).filter(Boolean);\n    this.lines = new Types<LineType>(lines || EMPTY_ARR);\n    this.formats = new Types(formats || EMPTY_ARR);\n    this.embeds = new Types(embeds || EMPTY_ARR);\n  }\n}\n\nexport function line(type: LineType) {\n  if (type.renderMultiple && !type.shouldCombine) type.shouldCombine = shouldCombine;\n  return lineTypes[type.name] = type;\n}\n\nexport function format(type: FormatType) {\n  return formatTypes[type.name] = type;\n}\n\nexport function embed(type: EmbedType) {\n  return embedTypes[type.name] = type;\n}\n\nexport type FromDom = (node: Node) => any;\nexport type LineData = [attributes: AttributeMap, children: VChild[], id:string];\nexport type Renderer = (attributes: AttributeMap, children: VChild[], editor: Editor, forHTML?: boolean) => VNode;\nexport type MultiLineRenderer = (lines: LineData[], editor: Editor, forHTML?: boolean) => VNode;\nexport type ShouldCombine = (prev: AttributeMap, next: AttributeMap) => boolean;\nexport interface Commands {\n  [name: string]: Function;\n}\n\n// A basic DOM type used in Typewriter views, either a line, format, or embed\nexport interface BasicType {\n  // Type name\n  name: string;\n\n  // A selector which matches this Type in the DOM\n  selector: string;\n\n  // A selector which matches this Type when found in a style (e.g. '[style*=\"italic\"]')\n  styleSelector?: string;\n\n  // Returns the attributes object for the Delta given a matching DOM node, or false if this DOM node should be ignored\n  fromDom?: FromDom | false;\n\n  commands?: (editor: Editor) => Commands | Function;\n\n  // Map of shortcuts to their command name\n  shortcuts?: Shortcuts | string;\n\n  // Renders the attributes from the format, or embed into a virtual dom representation\n  render?: Renderer;\n}\n\nexport interface FormatType extends BasicType {\n  greedy?: boolean;\n}\n\nexport interface EmbedType extends BasicType {\n  // If this embed doesn't fill any space, set noFill to true to add a <br> afterwards if nothing else is in the line\n  noFill?: boolean;\n}\n\nexport interface LineType extends BasicType {\n  // Whether this line can be indented/unindented with the tab key\n  indentable?: boolean;\n\n  // Whether the next line after this should be the default line or the same type\n  defaultFollows?: boolean;\n\n  // If this line is frozen, it cannot have contents and the selection cannot be inside it (an hr or custom line)\n  frozen?: boolean;\n\n  // If Enter and Delete on an empty line will remain contained within this line rather than converting it to a paragraph\n  contained?: boolean;\n\n  // When the Enter key is pressed within this line, what the next line's attributes should be\n  nextLineAttributes?: (attributes: AttributeMap) => AttributeMap;\n\n  // Renders the attributes from the delta line, format, or embed into a virtual dom representation\n  render?: Renderer;\n\n  // Renders the attributes from multiple delta lines into a virtual dom representation\n  renderMultiple?: MultiLineRenderer;\n\n  shouldCombine?: ShouldCombine;\n}\n\nexport interface TypesetTypes {\n  lines?: Array<string | LineType>;\n  formats?: Array<string | FormatType>;\n  embeds?: Array<string | EmbedType>;\n}\n\nexport interface TypeMap<T extends BasicType = BasicType> {\n  [name: string]: T;\n}\n\n/**\n * A type store to hold types and make it easy to manage them.\n */\nexport class Types<T extends BasicType = BasicType> {\n  // An array of the types\n  list: T[];\n\n  // A selector which will match all nodes of this type (e.g. all lines)\n  selector!: string;\n\n  // A map of all types by name\n  types!: TypeMap<T>;\n\n  // A reverse lookup of priority by type name\n  priorities!: { [name: string]: number };\n\n  constructor(types: T[]) {\n    this.list = types;\n    this.init();\n  }\n\n  get default() {\n    return this.list[0];\n  }\n\n  init() {\n    this.selector = this.list.map(type => type.selector || '').filter(Boolean).join(', ');\n    this.types = this.list.reduce((types, type) => {types[type.name] = type; return types}, {});\n    this.priorities = this.list.reduce((priorities, type, i) => {priorities[type.name] = i; return priorities}, {});\n  }\n\n  add(type: T) {\n    this.list.push(type);\n    this.init();\n  }\n\n  remove(type: T | string) {\n    const name = typeof type === 'string' ? type : type.name;\n    this.list = this.list.filter(type => type.name !== name);\n    this.init();\n  }\n\n  get(name: string) {\n    return this.types[name];\n  }\n\n  priority(name: string) {\n    // Attribute keys that do not have types assigned to them need a default sorting value.\n    // A default value of -1 means that \"loose\" attribute keys do not corrupt priority sorting\n    //   and are sorted to the back of the list in rendering.ts::renderInline()\n    const priority = this.priorities[name];\n    return priority !== undefined ? priority : -1;\n  }\n\n  // Whether or not the provided element is one of our types\n  matches(node: Node | null) {\n    if (!node) return false;\n    if (!node.nodeType) throw new Error('Cannot match against ' + node);\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      return this.selector ? (node as Element).matches(this.selector) : false;\n    }\n  }\n\n  // Find the first type by priority that matches this element\n  findByNode(node: Node, fallbackToDefault: true): T;\n  findByNode(node: Node, fallbackToDefault?: boolean): T | undefined;\n  findByNode(node: Node, fallbackToDefault = false) {\n    if (node.nodeType !== Node.ELEMENT_NODE) return;\n    let i = this.list.length;\n    while (i--) {\n      let type = this.list[i];\n      if ((node as Element).matches(type.selector)) return type;\n    }\n    if (fallbackToDefault) return this.default;\n  }\n\n  // Find the first type by priority that matches this attributes object. Can return the default for no match.\n  findByAttributes(attributes: AttributeMap | undefined, fallbackToDefault: true): T;\n  findByAttributes(attributes: AttributeMap | undefined, fallbackToDefault?: boolean): T | undefined;\n  findByAttributes(attributes: AttributeMap | undefined, fallbackToDefault = false): T | undefined {\n    const keys = attributes && Object.keys(attributes);\n    let type: T | undefined;\n    keys && keys.every(name => !(type = this.get(name)));\n    return type || (fallbackToDefault ? this.default : undefined);\n  }\n}\n","type Events = {[type: string]: Set<EventListener>};\ntype OnceEvents = {[type: string]: Map<EventListener,EventListener>};\nconst dispatcherEvents = new WeakMap<EventDispatcher, Events>();\nconst onceListeners = new WeakMap<EventDispatcher, OnceEvents>();\n\nexport default class EventDispatcher {\n\n  on(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    this.addEventListener(type, listener, options);\n  }\n\n  off(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    this.removeEventListener(type, listener, options);\n  }\n\n  addEventListener(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    if (options?.once) listener = getOnceListener(this, type, listener, true);\n    getEventListeners(this, type, true).add(listener);\n  }\n\n  removeEventListener(type: string, listener: EventListener, options?: AddEventListenerOptions) {\n    if (options?.once) listener = getOnceListener(this, type, listener) as EventListener;\n    if (!listener) return;\n    const events = getEventListeners(this, type);\n    events && events.delete(listener);\n  }\n\n  dispatchEvent(event: Event, catchErrors?: boolean) {\n    const events = getEventListeners(this, event.type);\n    if (!events) return;\n    for (let listener of events) {\n      if (catchErrors) {\n        try {\n          listener.call(this, event);\n        } catch (err) {\n          try {\n            this.dispatchEvent(new ErrorEvent('error', { error: err }));\n          } catch (err) {}\n        }\n      } else {\n        listener.call(this, event);\n      }\n      if (event.cancelBubble) break;\n    }\n  }\n}\n\n\nfunction getEventListeners(obj: EventDispatcher, type: string, autocreate = false) {\n  let events = dispatcherEvents.get(obj) as Events;\n  if (!events && autocreate) dispatcherEvents.set(obj, events = Object.create(null));\n  return events && events[type] || autocreate && (events[type] = new Set());\n}\n\nfunction getOnceListener(obj: EventDispatcher, type: string, listener: EventListener, autocreate = false): EventListener {\n  let events = onceListeners.get(obj) as OnceEvents;\n  if (!events && autocreate) dispatcherEvents.set(obj, events = Object.create(null));\n  const map = events && events[type] || autocreate && (events[type] = new Map());\n  if (!map.has(listener) && autocreate) {\n    const wrapper = event => {\n      const events = getEventListeners(obj, type);\n      events && events.delete(listener);\n      listener.call(obj, event);\n    }\n    map.set(listener, wrapper);\n  }\n  return map && map.get(listener) as EventListener;\n}\n","// Put it in document order (lower number first)\nexport function normalizeRange(range) {\n    if (!range)\n        return range;\n    if (range[0] > range[1])\n        range = [range[1], range[0]];\n    return range;\n}\n","import { Delta, isEqual } from '@typewriter/delta';\nconst EMPTY_MAP = new Map();\nconst INFINITY = {\n    id: '',\n    attributes: {},\n    content: new Delta([{ retain: Infinity }]),\n    length: Infinity,\n};\nvar Line;\n(function (Line) {\n    function iterator(lines, lineIds) {\n        return new LineIterator(lines, lineIds);\n    }\n    Line.iterator = iterator;\n    function linesToLineIds(lines) {\n        const lineIds = new Map();\n        lines.forEach((line) => lineIds.set(line.id || Line.createId(lineIds), line));\n        return lineIds;\n    }\n    Line.linesToLineIds = linesToLineIds;\n    function length(line) {\n        return line.length;\n    }\n    Line.length = length;\n    function getId(line) {\n        console.warn('getId() is deprecated');\n        return line.id;\n    }\n    Line.getId = getId;\n    function equal(value, other) {\n        return (isEqual(value.attributes, other.attributes) &&\n            isEqual(value.content.ops, other.content.ops));\n    }\n    Line.equal = equal;\n    function fromDelta(delta, existing) {\n        const lines = [];\n        const ids = new Map(existing || []);\n        delta.eachLine((content, attr) => {\n            const line = Line.create(content, Object.keys(attr).length ? attr : undefined, ids);\n            ids.set(line.id, line);\n            lines.push(line);\n        });\n        return lines;\n    }\n    Line.fromDelta = fromDelta;\n    function toDelta(lines) {\n        let delta = new Delta();\n        lines.forEach((line) => {\n            delta = delta.concat(line.content);\n            delta.insert('\\n', line.attributes);\n        });\n        return delta;\n    }\n    Line.toDelta = toDelta;\n    function create(content = new Delta(), attributes = {}, id) {\n        const length = content.length() + 1;\n        if (typeof id !== 'string')\n            id = createId(id);\n        return { id, attributes, content: content, length };\n    }\n    Line.create = create;\n    function createFrom(line, content = new Delta(), lineIds) {\n        const id = line ? line.id : createId(lineIds);\n        const attributes = line ? line.attributes : {};\n        return { id, attributes, content, length: 1 };\n    }\n    Line.createFrom = createFrom;\n    function getLineRanges(lines) {\n        const ranges = new Map();\n        let pos = 0;\n        lines.forEach((line) => {\n            ranges.set(line, [pos, (pos += line.length)]);\n        });\n        return ranges;\n    }\n    Line.getLineRanges = getLineRanges;\n    function createId(existing = EMPTY_MAP) {\n        let id;\n        while (existing[(id = Math.random().toString(36).slice(2))])\n            ;\n        return id;\n    }\n    Line.createId = createId;\n})(Line || (Line = {}));\nexport default Line;\nexport class LineIterator {\n    constructor(lines, lineIds) {\n        this.lines = lines;\n        this.index = 0;\n        this.offset = 0;\n        this.lineIds = lineIds ? new Map(lineIds) : Line.linesToLineIds(lines);\n    }\n    hasNext() {\n        return !!this.peek();\n    }\n    next(length) {\n        if (!length) {\n            length = Infinity;\n        }\n        const nextLine = this.lines[this.index];\n        if (nextLine) {\n            const offset = this.offset;\n            const lineLength = nextLine.length;\n            if (length >= lineLength - offset) {\n                length = lineLength - offset;\n                this.index += 1;\n                this.offset = 0;\n            }\n            else {\n                this.offset += length;\n            }\n            if (offset === 0 && length >= nextLine.length) {\n                return nextLine;\n            }\n            else {\n                const id = offset === 0 ? nextLine.id : Line.createId(this.lineIds);\n                const partialLine = {\n                    id,\n                    attributes: nextLine.attributes,\n                    content: nextLine.content.slice(offset, length),\n                    length: length - offset,\n                };\n                if (offset !== 0)\n                    this.lineIds.set(id, partialLine);\n                return partialLine;\n            }\n        }\n        else {\n            return INFINITY;\n        }\n    }\n    peek() {\n        return this.lines[this.index];\n    }\n    peekLength() {\n        if (this.lines[this.index]) {\n            // Should never return 0 if our index is being managed correctly\n            return this.lines[this.index].length - this.offset;\n        }\n        else {\n            return Infinity;\n        }\n    }\n    rest() {\n        if (!this.hasNext()) {\n            return [];\n        }\n        else if (this.offset === 0) {\n            return this.lines.slice(this.index);\n        }\n        else {\n            const offset = this.offset;\n            const index = this.index;\n            const next = this.next();\n            const rest = this.lines.slice(this.index);\n            this.offset = offset;\n            this.index = index;\n            return [next].concat(rest);\n        }\n    }\n}\n","import Line from './Line';\nimport { Op, OpIterator } from '@typewriter/delta';\nvar LineOp;\n(function (LineOp) {\n    function iterator(lines, lineIds) {\n        return new LineOpIterator(lines, lineIds);\n    }\n    LineOp.iterator = iterator;\n    function length(op) {\n        return Op.length(op);\n    }\n    LineOp.length = length;\n})(LineOp || (LineOp = {}));\nexport default LineOp;\nexport class LineOpIterator {\n    constructor(lines, lineIds) {\n        this.lineIterator = Line.iterator(lines, lineIds);\n        const line = this.lineIterator.peek();\n        this.opIterator = Op.iterator((line === null || line === void 0 ? void 0 : line.content.ops) || []);\n    }\n    hasNext() {\n        return this.opIterator.hasNext() || this.lineIterator.hasNext();\n    }\n    next(length) {\n        let op = this.opIterator.next(length);\n        if (op.retain === Infinity && this.lineIterator.hasNext()) {\n            op = getLineOp(this.nextLine());\n        }\n        return op;\n    }\n    nextLine() {\n        const line = this.lineIterator.next();\n        const nextLine = this.lineIterator.peek();\n        this.opIterator = new OpIterator((nextLine === null || nextLine === void 0 ? void 0 : nextLine.content.ops) || []);\n        return line;\n    }\n    peek() {\n        if (this.opIterator.hasNext() || !this.lineIterator.hasNext()) {\n            return this.opIterator.peek();\n        }\n        else {\n            return getLineOp(this.peekLine());\n        }\n    }\n    peekLine() {\n        return this.lineIterator.peek();\n    }\n    peekLength() {\n        if (this.opIterator.hasNext() || !this.lineIterator.hasNext()) {\n            return this.opIterator.peekLength();\n        }\n        else {\n            return 1; // a newline is length 1\n        }\n    }\n    peekLineLength() {\n        return this.lineIterator.peekLength();\n    }\n    peekType() {\n        if (this.opIterator.hasNext()) {\n            return this.opIterator.peekType();\n        }\n        else if (this.lineIterator.hasNext()) {\n            return 'insert'; // insert: '\\n'\n        }\n        else {\n            return 'retain';\n        }\n    }\n    restCurrentLine() {\n        return this.opIterator.rest();\n    }\n    restLines() {\n        if (this.opIterator.offset) {\n            this.lineIterator.next(this.opIterator.offset);\n        }\n        return this.lineIterator.rest();\n    }\n}\nfunction getLineOp(line) {\n    const op = { insert: '\\n' };\n    if (line.attributes)\n        op.attributes = line.attributes;\n    return op;\n}\n","import { Delta, AttributeMap, Op, isEqual } from '@typewriter/delta';\nimport { normalizeRange } from './EditorRange';\nimport { deltaToText } from './deltaToText';\nexport default class TextChange {\n    constructor(doc, delta = new Delta(), selection, activeFormats) {\n        this._pos = 0;\n        this.doc = doc;\n        this.delta = delta;\n        this.selection = selection;\n        this.activeFormats = activeFormats;\n    }\n    get contentChanged() {\n        return this.delta.ops.length > 0;\n    }\n    get selectionChanged() {\n        var _a;\n        return (this.selection !== undefined &&\n            !isEqual(this.selection, (_a = this.doc) === null || _a === void 0 ? void 0 : _a.selection));\n    }\n    apply() {\n        throw new Error('Must be overridden by creator of change (e.g. Editor).');\n    }\n    setDelta(delta) {\n        this.delta = delta;\n        this._pos = delta.length();\n        return this;\n    }\n    setActiveFormats(activeFormats) {\n        this.activeFormats = activeFormats;\n        return this;\n    }\n    select(at) {\n        this.selection = typeof at === 'number' ? [at, at] : at;\n        return this;\n    }\n    delete(range, options) {\n        if (!range || !this.doc)\n            return this;\n        let [at, to] = normalizeRange(range);\n        at = Math.max(0, at);\n        to = Math.min(this.doc.length - 1, to);\n        if (at === to)\n            return this;\n        const length = to - at;\n        if (this.doc.selection)\n            this.selection = [at, at];\n        this.compose(at, (delta) => delta.delete(length), length);\n        const lineRange = this.doc.getLineRange(at);\n        if (!(options === null || options === void 0 ? void 0 : options.dontFixNewline) && lineRange[1] <= to) {\n            const format = this.doc.getLineAt(at).attributes;\n            this.formatLine(to, format);\n        }\n        return this;\n    }\n    insert(at, insert, format, options) {\n        if (!this.doc)\n            return this;\n        at = this.normalizePoint(at);\n        if (this.doc.selection) {\n            const end = at + (typeof insert === 'string' ? insert.length : 1);\n            this.selection = [end, end];\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { id, ...lineFormat } = this.doc.getLineAt(at).attributes;\n        if (typeof insert !== 'string') {\n            this.compose(at, (delta) => delta.insert(insert, format));\n        }\n        else if (insert === '\\n') {\n            if (options === null || options === void 0 ? void 0 : options.dontFixNewline) {\n                this.compose(at, (delta) => delta.insert('\\n', { ...format }));\n            }\n            else {\n                this.compose(at, (delta) => delta.insert('\\n', lineFormat));\n                this.formatLine(at, { ...format });\n            }\n        }\n        else {\n            if (!format)\n                format = this.getFormatAt(at);\n            if (insert.includes('\\n')) {\n                const lines = insert.split('\\n');\n                this.compose(at, (delta) => {\n                    lines.forEach((line, i) => {\n                        if (i)\n                            delta.insert('\\n', i === 1 ? lineFormat : {});\n                        if (line.length)\n                            delta.insert(line, format);\n                    });\n                    return delta;\n                });\n                if (lineFormat) {\n                    this.formatLine(at, { ...lineFormat });\n                }\n            }\n            else {\n                this.compose(at, (delta) => delta.insert(insert, format));\n            }\n        }\n        return this;\n    }\n    insertContent(at, content) {\n        if (!this.doc)\n            return this;\n        at = this.normalizePoint(at);\n        if (this.doc.selection) {\n            // Ignore retain ops at the end\n            const ops = content.ops.filter((op) => op.delete);\n            while (ops.length && ops[ops.length - 1].retain)\n                ops.pop();\n            const end = at + ops.reduce((length, op) => length + Op.length(op), 0);\n            this.selection = [end, end];\n        }\n        const text = deltaToText(content);\n        const newlineIndex = text.indexOf('\\n');\n        if (newlineIndex !== -1) {\n            this.formatLine(at, { ...this.doc.getLineFormat(at) });\n        }\n        this.compose(at, (delta) => delta.concat(content));\n        return this;\n    }\n    formatText(range, format) {\n        if (!this.doc)\n            return this;\n        range = normalizeRange(range);\n        const length = range[1] - range[0];\n        if (!length)\n            return this;\n        if (format) {\n            Object.keys(format).forEach((name) => format[name] === false && (format[name] = null));\n        }\n        // get lines for at-to and apply, skipping newlines\n        this.doc.getLineRanges(range).forEach(([start, end]) => {\n            start = Math.max(range[0], start);\n            end = Math.min(range[1], end - 1);\n            const length = end - start;\n            this.compose(start, (delta) => delta.retain(length, format), length);\n        });\n        return this;\n    }\n    toggleTextFormat(range, format) {\n        if (!this.doc)\n            return this;\n        if (typeof range === 'number')\n            range = [range, range];\n        range = normalizeRange(range);\n        const existing = this.doc.getTextFormat(range);\n        if (hasFormat(format, existing))\n            format = AttributeMap.invert(format);\n        return this.formatText(range, format);\n    }\n    formatLine(range, format, decoration) {\n        if (!this.doc)\n            return this;\n        const doc = this.doc;\n        if (typeof range === 'number')\n            range = [range, range];\n        range = normalizeRange(range);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.doc.getLineRanges(range).forEach(([start, end]) => {\n            end--;\n            if (!decoration) {\n                const undoFormat = AttributeMap.invert(doc.getLineFormat(end));\n                format = { ...undoFormat, ...format };\n            }\n            this.compose(end, (delta) => delta.retain(1, format), 1);\n        });\n        this.delta.chop();\n        return this;\n    }\n    toggleLineFormat(range, format) {\n        if (!this.doc)\n            return this;\n        if (typeof range === 'number')\n            range = [range, range];\n        range = normalizeRange(range);\n        const existing = this.doc.getLineFormat(range);\n        if (hasFormat(format, existing))\n            format = AttributeMap.invert(format);\n        return this.formatLine(range, format);\n    }\n    removeFormat(range) {\n        if (!this.doc)\n            return this;\n        range = normalizeRange(range);\n        const undo = AttributeMap.invert(this.doc.getFormats(range));\n        const length = range[1] - range[0];\n        return this.compose(range[0], (delta) => delta.retain(length, undo), length);\n    }\n    transform(change, priority) {\n        const delta = this.delta.transform(change.delta, priority);\n        const selection = change.selection && this.transformSelection(change.selection);\n        return new TextChange(null, delta, selection);\n    }\n    transformSelection(selection, priority) {\n        if (!selection)\n            return selection;\n        const from = this.delta.transformPosition(selection[0], priority);\n        const to = this.delta.transformPosition(selection[1], priority);\n        if (from === selection[0] && to === selection[1])\n            return selection;\n        return [from, to];\n    }\n    transformAgainst(delta, priority) {\n        const change = delta.ops\n            ? new TextChange(null, delta)\n            : delta;\n        return change.transform(this, !priority);\n    }\n    isFor(doc) {\n        return this.doc === doc;\n    }\n    clone() {\n        var _a;\n        return new TextChange(this.doc, new Delta(this.delta.ops.slice()), (_a = this.selection) === null || _a === void 0 ? void 0 : _a.slice());\n    }\n    compose(at, applicator, length) {\n        if (this._pos <= at) {\n            this.delta = applicator(this.delta.retain(at - this._pos));\n        }\n        else {\n            this.delta = this.delta.compose(applicator(new Delta().retain(at)));\n        }\n        this._pos = Math.max(at + (length || 0), this._pos);\n        return this;\n    }\n    normalizePoint(at, maxLength = this.doc ? this.doc.length - 1 : 0) {\n        return Math.max(0, Math.min(maxLength, at));\n    }\n    getFormatAt(at) {\n        let format = undefined;\n        if (this.doc) {\n            // Only keep the format if it is present on both sides of the cursor\n            const attr1 = this.doc.getTextFormat(at);\n            const attr2 = this.doc.getTextFormat(at + 1);\n            if (attr1 && attr2) {\n                format = attr1 === attr2 ? attr1 : intersect(attr2, Object.keys(attr1));\n            }\n        }\n        return format;\n    }\n}\nexport function hasFormat(format, attributes) {\n    return Object.keys(format).every((name) => isEqual(attributes[name], format[name]));\n}\nexport function intersect(value, other) {\n    const obj = {};\n    Object.keys(value).forEach((key) => {\n        if (value[key] === other[key])\n            obj[key] = value[key];\n    });\n    return obj;\n}\n","/* eslint-disable prettier/prettier */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Delta, AttributeMap, Op, isEqual } from '@typewriter/delta';\nimport Line from './Line';\nimport LineOp from './LineOp';\nimport { normalizeRange } from './EditorRange';\nimport TextChange from './TextChange';\nimport { deltaToText } from './deltaToText';\nconst EMPTY_RANGE = [0, 0];\nconst EMPTY_OBJ = {};\nconst DELTA_CACHE = new WeakMap();\nconst excludeProps = new Set(['id']);\nexport default class TextDocument {\n    constructor(linesOrDocOrDelta, selection = null) {\n        if (linesOrDocOrDelta && linesOrDocOrDelta.lines) {\n            const textDocument = linesOrDocOrDelta;\n            this.lines = textDocument.lines;\n            this.byId = textDocument.byId;\n            this._ranges = textDocument._ranges;\n            this.length = textDocument.length;\n        }\n        else {\n            this.byId = new Map();\n            if (linesOrDocOrDelta && Array.isArray(linesOrDocOrDelta)) {\n                this.lines = linesOrDocOrDelta;\n            }\n            else if (linesOrDocOrDelta) {\n                this.lines = Line.fromDelta(linesOrDocOrDelta);\n            }\n            else {\n                this.lines = [Line.create()];\n            }\n            if (!this.lines.length) {\n                this.lines.push(Line.create());\n            }\n            this.byId = Line.linesToLineIds(this.lines);\n            // Check for line id duplicates (should never happen, indicates bug)\n            this.lines.forEach((line) => {\n                if (this.byId.get(line.id) !== line)\n                    throw new Error('TextDocument has duplicate line ids: ' + line.id);\n            });\n            this._ranges = Line.getLineRanges(this.lines);\n            this.length = this.lines.reduce((length, line) => length + line.length, 0);\n        }\n        this.selection =\n            selection &&\n                selection.map((index) => Math.min(this.length - 1, Math.max(0, index)));\n    }\n    get change() {\n        const change = new TextChange(this);\n        change.apply = () => this.apply(change);\n        return change;\n    }\n    getText(range) {\n        if (range)\n            range = normalizeRange(range);\n        return deltaToText(range ? this.slice(range[0], range[1]) : this.slice(0, this.length - 1));\n    }\n    getLineBy(id) {\n        return this.byId.get(id);\n    }\n    getLineAt(at) {\n        return this.lines.find((line) => {\n            const [start, end] = this.getLineRange(line);\n            return start <= at && end > at;\n        });\n    }\n    getLinesAt(at, encompassed) {\n        let to = at;\n        if (Array.isArray(at))\n            [at, to] = normalizeRange(at);\n        return this.lines.filter((line) => {\n            const [start, end] = this.getLineRange(line);\n            return encompassed\n                ? start >= at && end <= to\n                : (start < to || start === at) && end > at;\n        });\n    }\n    getLineRange(at) {\n        const { lines, _ranges: lineRanges } = this;\n        if (typeof at === 'number') {\n            for (let i = 0; i < lines.length; i++) {\n                const range = lineRanges.get(lines[i]) || EMPTY_RANGE;\n                if (range[0] <= at && range[1] > at)\n                    return range;\n            }\n            return EMPTY_RANGE;\n        }\n        else {\n            if (typeof at === 'string')\n                at = this.getLineBy(at);\n            return lineRanges.get(at);\n        }\n    }\n    getLineRanges(at) {\n        if (at == null) {\n            return Array.from(this._ranges.values());\n        }\n        else {\n            return this.getLinesAt(at).map((line) => this.getLineRange(line));\n        }\n    }\n    getLineFormat(at = this.selection, options) {\n        let to = at;\n        if (Array.isArray(at))\n            [at, to] = normalizeRange(at);\n        if (at === to)\n            to++;\n        return getAttributes(Line, this.lines, at, to, undefined, options);\n    }\n    getTextFormat(at = this.selection, options) {\n        let to = at;\n        if (Array.isArray(at))\n            [at, to] = normalizeRange(at);\n        if (at === to)\n            at--;\n        return getAttributes(LineOp, this.lines, at, to, (op) => op.insert !== '\\n', options);\n    }\n    getFormats(at = this.selection, options) {\n        return {\n            ...this.getTextFormat(at, options),\n            ...this.getLineFormat(at, options),\n        };\n    }\n    slice(start = 0, end = Infinity) {\n        const ops = [];\n        const iter = LineOp.iterator(this.lines);\n        let index = 0;\n        while (index < end && iter.hasNext()) {\n            let nextOp;\n            if (index < start) {\n                nextOp = iter.next(start - index);\n            }\n            else {\n                nextOp = iter.next(end - index);\n                ops.push(nextOp);\n            }\n            index += Op.length(nextOp);\n        }\n        return new Delta(ops);\n    }\n    apply(change, selection, throwOnError) {\n        let delta;\n        if (change.delta) {\n            delta = change.delta;\n            selection = change.selection;\n        }\n        else {\n            delta = change;\n        }\n        // If no change, do nothing\n        if (!delta.ops.length &&\n            (selection === undefined || isEqual(this.selection, selection))) {\n            return this;\n        }\n        // Optimization for selection-only change\n        if (!delta.ops.length && selection) {\n            return new TextDocument(this, selection);\n        }\n        if (selection === undefined && this.selection) {\n            selection = [\n                delta.transformPosition(this.selection[0]),\n                delta.transformPosition(this.selection[1]),\n            ];\n            // If the selection hasn't changed, keep the original reference\n            if (isEqual(this.selection, selection)) {\n                selection = this.selection;\n            }\n        }\n        const thisIter = LineOp.iterator(this.lines, this.byId);\n        const otherIter = Op.iterator(delta.ops);\n        const lines = [];\n        const firstChange = otherIter.peek();\n        if (firstChange && firstChange.retain && !firstChange.attributes) {\n            let firstLeft = firstChange.retain;\n            while (thisIter.peekLineLength() <= firstLeft) {\n                firstLeft -= thisIter.peekLineLength();\n                lines.push(thisIter.nextLine());\n            }\n            if (firstChange.retain - firstLeft > 0) {\n                otherIter.next(firstChange.retain - firstLeft);\n            }\n        }\n        if (!thisIter.hasNext()) {\n            if (throwOnError)\n                throw new Error('apply() called with change that extends beyond document');\n        }\n        let line = Line.createFrom(thisIter.peekLine());\n        // let wentBeyond = false;\n        function addLine(line) {\n            line.length = line.content.length() + 1;\n            lines.push(line);\n        }\n        while (thisIter.hasNext() || otherIter.hasNext()) {\n            if (otherIter.peekType() === 'insert') {\n                const otherOp = otherIter.peek();\n                const index = typeof otherOp.insert === 'string'\n                    ? otherOp.insert.indexOf('\\n', otherIter.offset)\n                    : -1;\n                if (index < 0) {\n                    line.content.push(otherIter.next());\n                }\n                else {\n                    const nextIndex = index - otherIter.offset;\n                    if (nextIndex)\n                        line.content.push(otherIter.next(nextIndex));\n                    const newlineOp = otherIter.next(1);\n                    addLine(Line.create(line.content, newlineOp.attributes));\n                    line.content = new Delta();\n                }\n            }\n            else {\n                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n                const thisOp = thisIter.next(length);\n                const otherOp = otherIter.next(length);\n                if (typeof thisOp.retain === 'number') {\n                    if (throwOnError)\n                        throw new Error('apply() called with change that extends beyond document');\n                    // line.content.push({ insert: '#'.repeat(otherOp.retain || 1) });\n                    // wentBeyond = true;\n                    continue;\n                }\n                if (typeof otherOp.retain === 'number') {\n                    const isLine = thisOp.insert === '\\n';\n                    let newOp = thisOp;\n                    // Preserve null when composing with a retain, otherwise remove it for inserts\n                    const attributes = otherOp.attributes &&\n                        AttributeMap.compose(thisOp.attributes, otherOp.attributes);\n                    if (otherOp.attributes && !isEqual(attributes, thisOp.attributes)) {\n                        if (isLine) {\n                            line.attributes = attributes || {};\n                        }\n                        else {\n                            newOp = { insert: thisOp.insert };\n                            if (attributes)\n                                newOp.attributes = attributes;\n                        }\n                    }\n                    if (isLine) {\n                        addLine(line);\n                        line = Line.createFrom(thisIter.peekLine());\n                    }\n                    else {\n                        line.content.push(newOp);\n                    }\n                    // Optimization if at the end of other\n                    if (otherOp.retain === Infinity || !otherIter.hasNext()) {\n                        if (thisIter.opIterator.index !== 0 ||\n                            thisIter.opIterator.offset !== 0) {\n                            const ops = thisIter.restCurrentLine();\n                            for (let i = 0; i < ops.length; i++) {\n                                line.content.push(ops[i]);\n                            }\n                            addLine(line);\n                            thisIter.nextLine();\n                        }\n                        lines.push(...thisIter.restLines());\n                        break;\n                    }\n                }\n                else if (typeof otherOp.delete === 'number') {\n                    if (thisOp.insert === '\\n') {\n                        // Be sure a deleted line is not kept\n                        line = Line.createFrom(thisIter.peekLine(), line.content);\n                    }\n                    // else ... otherOp should be a delete so we won't add the next thisOp insert\n                }\n            }\n        }\n        // if (wentBeyond) {\n        //   console.log('went beyond:', line);\n        //   addLine(line);\n        // }\n        return new TextDocument(lines, selection);\n    }\n    replace(delta, selection) {\n        return new TextDocument(delta, selection);\n    }\n    toDelta() {\n        const cache = DELTA_CACHE;\n        let delta = cache.get(this);\n        if (!delta) {\n            delta = Line.toDelta(this.lines);\n            cache.set(this, delta);\n        }\n        return delta;\n    }\n    equals(other, options) {\n        return (this === other ||\n            (((options === null || options === void 0 ? void 0 : options.contentOnly) || isEqual(this.selection, other.selection)) &&\n                isEqual(this.lines, other.lines, { excludeProps })));\n    }\n    toJSON() {\n        return this.toDelta();\n    }\n    toString() {\n        return (this.lines\n            .map((line) => line.content\n            .map((op) => (typeof op.insert === 'string' ? op.insert : ' '))\n            .join(''))\n            .join('\\n') + '\\n');\n    }\n}\nfunction getAttributes(Type, data, from, to, filter, options) {\n    const iter = Type.iterator(data);\n    let attributes;\n    let index = 0;\n    if (iter.skip)\n        index += iter.skip(from);\n    while (index < to && iter.hasNext()) {\n        const next = iter.next();\n        index += Type.length(next);\n        if (index > from && (!filter || filter(next))) {\n            if (!next.attributes)\n                attributes = {};\n            else if (!attributes)\n                attributes = { ...next.attributes };\n            else if (options === null || options === void 0 ? void 0 : options.allFormats)\n                attributes = AttributeMap.compose(attributes, next.attributes);\n            else\n                attributes = intersectAttributes(attributes, next.attributes, options === null || options === void 0 ? void 0 : options.nameOnly);\n        }\n    }\n    return attributes || EMPTY_OBJ;\n}\n// Intersect 2 attibute maps, keeping only those that are equal in both\nfunction intersectAttributes(attributes, other, nameOnly) {\n    return Object.keys(other).reduce(function (intersect, name) {\n        if (nameOnly) {\n            if (name in attributes && name in other)\n                intersect[name] = true;\n        }\n        else if (isEqual(attributes[name], other[name], { partial: true })) {\n            intersect[name] = other[name];\n        }\n        else if (isEqual(other[name], attributes[name], { partial: true })) {\n            intersect[name] = attributes[name];\n        }\n        return intersect;\n    }, {});\n}\n","export function deltaToText(delta) {\n    return delta\n        .map((op) => typeof op.insert === 'string' ? op.insert : op.insert ? ' ' : '')\n        .join('');\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"names":["__importDefault","this","mod","__esModule","Object","defineProperty","exports","value","cloneDeep_1","isEqual_1","isObject","Array","isArray","isDeepNull","key","AttributeMap","compose","a","b","keepNull","attributes","default","keys","reduce","copy","undefined","length","diff","concat","attrs","invert","attr","base","baseInverted","memo","transform","priority","fast_diff_1","AttributeMap_1","Op_1","NULL_CHARACTER","String","fromCharCode","Delta","constructor","ops","insert","arg","newOp","push","delete","retain","index","lastOp","unshift","splice","chop","pop","filter","predicate","forEach","map","partition","passed","failed","op","initialValue","changeLength","elem","slice","start","end","Infinity","iter","iterator","hasNext","nextOp","next","other","discardNull","thisIter","otherIter","firstOther","peek","firstLeft","peekType","peekLength","delta","Math","min","thisOp","otherOp","rest","cursor","strings","Error","join","retDelta","diffResult","component","opLength","INSERT","DELETE","EQUAL","eachLine","newline","line","i","indexOf","inverted","baseIndex","baseOp","transformPosition","offset","nextType","Op","module","OpIterator","retOp","substr","isEqual","cloneDeep","enumerable","get","Delta_1","toJSON","clone","EMPTY_OBJ","exactlyEqual","options","valueType","otherType","isNaN","valueOf","compare","shallow","Symbol","valueIter","valueResult","otherResult","done","valueKeys","otherKeys","excludeProps","isIncluded","excluded","prop","has","partial","every","hasOwnProperty","DIFF_DELETE","diff_main","text1","text2","cursor_pos","_fix_unicode","editdiff","oldText","newText","oldRange","newRange","oldLength","newLength","oldCursor","oldBefore","oldAfter","maybeNewCursor","newCursor","newBefore","newAfter","prefixLength","oldPrefix","newPrefix","make_edit_splice","suffixLength","oldSuffix","newSuffix","find_cursor_edit_diff","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","diffs","longtext","shorttext","hm","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","floor","j","best_common","text1_a","text1_b","text2_a","text2_b","hm1","ceil","hm2","diff_halfMatch_","mid_common","diffs_a","diffs_b","text1_length","text2_length","max_d","v_offset","v_length","v1","v2","x","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","y1","x1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","diff_bisect_","diff_compute_","diff_cleanupMerge","y","text1a","text2a","text1b","text2b","diffsb","pointermin","pointermax","pointermid","pointerstart","is_surrogate_pair_start","charCodeAt","pointerend","is_surrogate_pair_end","fix_unicode","pointer","count_delete","count_insert","text_delete","text_insert","previous_equality","ends_with_pair_start","stray","k","starts_with_pair_end","n","changes","charCode","str","before","oldMiddle","newMiddle","after","tuples","ret","remove_empty_tuples","EMPTY_ARR","PROXIED_EVENTS","eventProxies","WeakMap","EditorChangeEvent","Event","type","init","super","old","doc","change","changedLines","source","setPrototypeOf","prototype","modify","cancelable","apply","lines","getChangedLines","EditorFormatEvent","formats","Editor","activeFormats","commands","shortcuts","modules","catchErrors","dev","identifier","typeset","types","html","text","TextDocument","throwOnError","_enabled","enabled","_modules","root","setRoot","_root","document","createElement","changed","selection","select","contentEditable","dispatchEvent","TextChange","update","TypeError","destroy","changeOrDelta","set","docOrDelta","equals","changingEvent","defaultPrevented","getActiveFormats","getHTML","setHTML","getDelta","toDelta","setDelta","getText","range","setText","trimSelection","selectedText","from","to","normalizeRange","trim","_","lead","tail","match","getActive","active","getLineFormat","getFormats","values","at","format","inPlace","findByAttributes","setActiveFormats","frozen","lineFormat","secondLine","lastLine","newlines","getLineRange","insertContent","formatLine","content","directionOrSelection","formatText","changeFormat","toggleTextFormat","hasFormat","toggleLineFormat","indent","indentLines","outdent","removeFormat","getBounds","relativeTo","relativeInside","rect","getBoundingClientRect","relative","leftOffset","scrollLeft","topOffset","scrollTop","DOMRect","width","height","getAllBounds","collection","getClientRects","list","getIndexFromPoint","render","decorations","gatherDecorations","rendering","renderSelection","editor","addEventListener","getEventProxy","mergeCommands","name","embeds","all","mergeTypeShortcuts","mergeShortcuts","mergeModuleShortcuts","createShortcutMap","removeEventListener","formatAt","formatTo","getTextFormat","nextAttributes","greedy","oldDoc","newDoc","Set","enhanceCommand","command","args","result","focus","direction","getLinesAt","indentable","proxy","eventProxy","bind","event","typeShortcuts","shortcut","Source","defaultOptions","copyPlainText","copyHTML","empty","getCopy","includes","onCopy","preventDefault","dataTransfer","clipboardData","setData","onCut","endInSemicolon","formatDecoration","selector","fromDom","children","applyDecorations","h","embedDecoration","noFill","classes","props","decoration","class","DecorateEvent","add","Map","original","decorating","removeDecorations","size","clearDecorations","clear","existing","onChange","contentChanged","origLine","id","onRender","on","getDecorator","Decorator","off","remove","_name","_doc","_decoration","_apply","_remove","hasDecorations","getDecoration","clearLines","pos","clearLine","getLineAt","getLineBy","decorateText","decorateLine","insertDecoration","vnode","defaultClasses","styles","className","style","test","docDelta","defaultModules","keyboard","input","paste","history","initOptions","lastRecorded","lastAction","ignoreChange","stack","undo","redo","maxStack","delay","onBeforeInput","inputType","action","hasUndo","hasRedo","cutoffHistory","clearHistory","dest","entry","timestamp","Date","now","head","changeOp","getAction","shift","record","transformHistoryStack","setStack","getStack","initHistory","undoStack","placeholder","onDecorate","decorator","lastDecorations","showPlaceholder","keepAttribute","straitQuotes","nonchar","conversions","left","right","smartQuotes","onTextChange","indices","exec","getQuoteIndices","convert","quote","converted","lineReplacements","capture","header","char","chars","toUpperCase","fromRomanNumeral","blockquote","linkReplacements","link","textReplacements","defaultHandlers","prefix","some","regexp","getAttributes","replaceWith","smartEntry","handlers","ignore","isTextEntry","lineStart","lastIndexOf","handler","DIGIT_VALUES","I","V","X","L","C","D","M","romanNumeral","currentLetter","nextLetter","isAndroid","navigator","maxTouchPoints","platform","userAgent","window","MSStream","MUTATION_OPTIONS","characterData","characterDataOldValue","subtree","childList","gboardEnter","onInput","mutations","observer","takeRecords","onMutate","mutation","textNodes","target","find","textAdd","addedNodes","nodeName","removedNodes","getTextChangeMutation","oldValue","nodeValue","relativeEditLocation","replace","string","getTextChange","startNode","endNode","nextElementSibling","collapseWhitespace","getChangeFromRange","records","getTopLine","getChangedLineRange","isBr","br","MutationObserver","onRendering","disconnect","observe","data","node","parentNode","IS_CHROME","chrome","onEnter","isCollapsed","atStart","atEnd","isEmpty","contained","defaultFollows","dontFixNewline","nextLineAttributes","handleDelete","ctrlKey","altKey","metaKey","unindent","mergingLine","first","second","force","onKeyDown","isComposing","checkShortcut","osShortcut","modShortcut","onShiftEnter","onTab","split","onBackspace","onDelete","ignoreId","PasteEvent","htmlParser","possiblePartial","hasLines","Line","byId","startLine","endLine","startAttrs","endAttrs","pastedStartLine","pastedStartAttrs","pastedEndLine","pastedEndAttrs","lastInsert","endsInNewline","endsWith","viewEvent","onPaste","getData","what","rootDocument","rootWindow","paused","onSelectionChange","focused","onMouseDown","onWindowFocus","classList","toggle","hasFocus","pause","resume","setTimeout","ownerDocument","defaultView","modifierKeys","Control","Meta","Shift","Alt","isMac","modExpr","ShortcutEvent","KeyboardEvent","static","shortcutFromEvent","addShortcutsToEvent","shortcutArray","shiftKey","code","startsWith","matchHtmlRegExp","escapeHtml","escape","lastIndex","BLOCK_ELEMENTS","BAD_CHARS","SKIP_ELEMENTS","STYLE","SCRIPT","LINK","META","TITLE","VOID_ELEMENTS","area","col","embed","hr","img","meta","param","track","wbr","whitespaceExp","textsNode","isBRPlaceholder","containingLine","closest","walker","currentNode","nextNode","HTMLElement","matches","isLastNode","docToHTML","childrenToHTML","inlineToHTML","docFromHTML","deltaFromHTML","deltaFromDom","DOMParser","parseFromString","body","cleanText","docFromDom","fromNode","dom","renderMultiple","currentLine","firstLineSeen","unknownLine","previousNode","nodeType","Node","TEXT_NODE","parent","previousSibling","nextSibling","nodeText","contains","gatherFormats","findByNode","ELEMENT_NODE","lastChild","includeIds","child","textContent","innerHTML","closingTag","nodeToHTML","hasAttribute","styleSelector","EMPTY_NODE_OFFSET","caretPositionFromPoint","getIndexFromNodeAndOffset","offsetNode","caretRangeFromPoint","startContainer","startOffset","getLineInfoFromPoint","lineElements","querySelectorAll","last","element","bottom","belowMid","top","getBrowserRange","anchorNode","anchorOffset","focusNode","focusOffset","getNodesForRange","browserRange","createRange","setStart","setEnd","getBoudingBrowserRange","endContainer","endOffset","e","current","childNodes","getNodeLength","getIndexFromNode","textNodeLength","getLineElementAt","anchorFirst","getNodeAndOffset","firstChild","BR","nodeFormatType","linesType","linesMultiples","linesCombined","nodeRanges","getLineNodeStart","getLineNodeEnd","setLineNodesRanges","combined","combineLines","ranges","byKey","lineElement","renderDoc","renderChanges","oldCombined","newCombined","getChangedRanges","max","oldSlice","newSlice","renderCombined","forHTML","renderLine","Boolean","renderMultiLine","renderSingleLine","getLineType","renderInline","cache","collect","shouldCombine","v","oldC","newC","minLength","oldStart","oldEnd","newStart","newEnd","isSame","inlineChildren","trailingBreak","array","prev","startsWithSpace","sort","mergeChildren","oldEntry","newEntry","oldChildren","getSelection","anchorIndex","isFrozen","setSelection","activeElement","removeAllRanges","setBaseAndExtent","bubbles","renderKeys","KEY_ATTR","domProps","getKey","vdom","setKey","setAttribute","removeAttribute","listener","currentTarget","events","patchProp","oldVal","newVal","isSvg","createNode","createTextNode","createElementNS","is","kid","appendChild","vdomify","getDomProps","patchDom","oldDom","newVdom","insertBefore","removeChild","toLowerCase","oldProps","newProps","patchChildren","newVKids","oldKids","tmpKid","oldKid","oldKey","newKey","oldHead","newHead","oldTail","newTail","oldKeyed","newKeyed","createVdom","recycleNode","call","ch","React","patch","SVGElement","SHOW","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","createTreeWalker","acceptNode","FILTER_REJECT","FILTER_ACCEPT","noop","run","fn","run_all","fns","is_function","thing","subscribe","store","callbacks","unsub","unsubscribe","get_store_value","SvelteElement","Promise","resolve","globalThis","global","attachShadow","mode","connectedCallback","on_mount","$$","on_disconnect","slotted","attributeChangedCallback","_oldValue","newValue","disconnectedCallback","$destroy","detaching","fragment","on_destroy","ctx","destroy_component","$on","callback","$set","$$props","obj","$$set","skip_bound","subscriber_queue","readable","writable","stop","subscribers","new_value","run_queue","subscriber","invalidate","EMPTY_NOPTIFIER","EMPTY_ACTIVE","EMPTY_DOC","EMPTY_SELECTION","EMPTY_ROOT","editorStores","activeStore","docStore","selectionStore","rootStore","focusStore","updateEditor","newActive","stores","initial_value","single","stores_array","auto","derived","inited","pending","cleanup","sync","unsubscribers","defaultValueOrStore","defaultValue","write","header1","header2","header3","header4","header5","header6","parseInt","bulletList","orderedList","checkList","toggleCheck","checked","getAttribute","lists","topLevelChildren","levels","check","onmousedown","ontouchstart","item","newLevel","childrenArray","compareLists","quotes","spellcheck","bold","italic","href","image","src","defaultTypes","lineTypes","formatTypes","embedTypes","Typeset","Types","priorities","fallbackToDefault","dispatcherEvents","onceListeners","EventDispatcher","once","getOnceListener","getEventListeners","err","ErrorEvent","error","cancelBubble","autocreate","create","wrapper","EMPTY_MAP","INFINITY","createId","random","toString","lineIds","LineIterator","linesToLineIds","getId","console","warn","equal","fromDelta","ids","createFrom","getLineRanges","nextLine","lineLength","partialLine","LineOp","LineOpIterator","lineIterator","opIterator","getLineOp","peekLine","peekLineLength","restCurrentLine","restLines","_pos","selectionChanged","_a","lineRange","normalizePoint","getFormatAt","undoFormat","transformSelection","transformAgainst","isFor","applicator","maxLength","attr1","attr2","intersect","EMPTY_RANGE","DELTA_CACHE","linesOrDocOrDelta","textDocument","_ranges","encompassed","lineRanges","firstChange","addLine","nextIndex","newlineOp","isLine","contentOnly","Type","skip","allFormats","intersectAttributes","nameOnly","deltaToText","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","definition","o","r","toStringTag"],"sourceRoot":""}